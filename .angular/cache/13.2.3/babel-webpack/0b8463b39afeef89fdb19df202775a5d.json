{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Development\\\\Fun\\\\ArchaicQuest-II-Web-Client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError } from \"./Errors\";\nimport { HeaderNames } from \"./HeaderNames\";\nimport { LogLevel } from \"./ILogger\";\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\nimport { LongPollingTransport } from \"./LongPollingTransport\";\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\nimport { WebSocketTransport } from \"./WebSocketTransport\";\nconst MAX_REDIRECTS = 100;\n/** @private */\n\nexport class HttpConnection {\n  constructor(url, options = {}) {\n    this._stopPromiseResolver = () => {};\n\n    this.features = {};\n    this._negotiateVersion = 1;\n    Arg.isRequired(url, \"url\");\n    this._logger = createLogger(options.logger);\n    this.baseUrl = this._resolveUrl(url);\n    options = options || {};\n    options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\n\n    if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\n      options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\n    } else {\n      throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n    }\n\n    options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\n    let webSocketModule = null;\n    let eventSourceModule = null;\n\n    if (Platform.isNode && typeof require !== \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n      webSocketModule = requireFunc(\"ws\");\n      eventSourceModule = requireFunc(\"eventsource\");\n    }\n\n    if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\n      options.WebSocket = WebSocket;\n    } else if (Platform.isNode && !options.WebSocket) {\n      if (webSocketModule) {\n        options.WebSocket = webSocketModule;\n      }\n    }\n\n    if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\n      options.EventSource = EventSource;\n    } else if (Platform.isNode && !options.EventSource) {\n      if (typeof eventSourceModule !== \"undefined\") {\n        options.EventSource = eventSourceModule;\n      }\n    }\n\n    this._httpClient = options.httpClient || new DefaultHttpClient(this._logger);\n    this._connectionState = \"Disconnected\"\n    /* Disconnected */\n    ;\n    this._connectionStarted = false;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  start(transferFormat) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      transferFormat = transferFormat || TransferFormat.Binary;\n      Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n\n      _this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\n\n      if (_this._connectionState !== \"Disconnected\"\n      /* Disconnected */\n      ) {\n        return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\n      }\n\n      _this._connectionState = \"Connecting\"\n      /* Connecting */\n      ;\n      _this._startInternalPromise = _this._startInternal(transferFormat);\n      yield _this._startInternalPromise; // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\n\n      if (_this._connectionState === \"Disconnecting\"\n      /* Disconnecting */\n      ) {\n        // stop() was called and transitioned the client into the Disconnecting state.\n        const message = \"Failed to start the HttpConnection before stop() was called.\";\n\n        _this._logger.log(LogLevel.Error, message); // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n\n\n        yield _this._stopPromise;\n        return Promise.reject(new Error(message));\n      } else if (_this._connectionState !== \"Connected\"\n      /* Connected */\n      ) {\n        // stop() was called and transitioned the client into the Disconnecting state.\n        const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n\n        _this._logger.log(LogLevel.Error, message);\n\n        return Promise.reject(new Error(message));\n      }\n\n      _this._connectionStarted = true;\n    })();\n  }\n\n  send(data) {\n    if (this._connectionState !== \"Connected\"\n    /* Connected */\n    ) {\n      return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\n    }\n\n    if (!this._sendQueue) {\n      this._sendQueue = new TransportSendQueue(this.transport);\n    } // Transport will not be null if state is connected\n\n\n    return this._sendQueue.send(data);\n  }\n\n  stop(error) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2._connectionState === \"Disconnected\"\n      /* Disconnected */\n      ) {\n        _this2._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\n\n        return Promise.resolve();\n      }\n\n      if (_this2._connectionState === \"Disconnecting\"\n      /* Disconnecting */\n      ) {\n        _this2._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\n\n        return _this2._stopPromise;\n      }\n\n      _this2._connectionState = \"Disconnecting\"\n      /* Disconnecting */\n      ;\n      _this2._stopPromise = new Promise(resolve => {\n        // Don't complete stop() until stopConnection() completes.\n        _this2._stopPromiseResolver = resolve;\n      }); // stopInternal should never throw so just observe it.\n\n      yield _this2._stopInternal(error);\n      yield _this2._stopPromise;\n    })();\n  }\n\n  _stopInternal(error) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // Set error as soon as possible otherwise there is a race between\n      // the transport closing and providing an error and the error from a close message\n      // We would prefer the close message error.\n      _this3._stopError = error;\n\n      try {\n        yield _this3._startInternalPromise;\n      } catch (e) {// This exception is returned to the user as a rejected Promise from the start method.\n      } // The transport's onclose will trigger stopConnection which will run our onclose event.\n      // The transport should always be set if currently connected. If it wasn't set, it's likely because\n      // stop was called during start() and start() failed.\n\n\n      if (_this3.transport) {\n        try {\n          yield _this3.transport.stop();\n        } catch (e) {\n          _this3._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\n\n          _this3._stopConnection();\n        }\n\n        _this3.transport = undefined;\n      } else {\n        _this3._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n      }\n    })();\n  }\n\n  _startInternal(transferFormat) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // Store the original base url and the access token factory since they may change\n      // as part of negotiating\n      let url = _this4.baseUrl;\n      _this4._accessTokenFactory = _this4._options.accessTokenFactory;\n\n      try {\n        if (_this4._options.skipNegotiation) {\n          if (_this4._options.transport === HttpTransportType.WebSockets) {\n            // No need to add a connection ID in this case\n            _this4.transport = _this4._constructTransport(HttpTransportType.WebSockets); // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n\n            yield _this4._startTransport(url, transferFormat);\n          } else {\n            throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n          }\n        } else {\n          let negotiateResponse = null;\n          let redirects = 0;\n\n          do {\n            negotiateResponse = yield _this4._getNegotiationResponse(url); // the user tries to stop the connection when it is being started\n\n            if (_this4._connectionState === \"Disconnecting\"\n            /* Disconnecting */\n            || _this4._connectionState === \"Disconnected\"\n            /* Disconnected */\n            ) {\n              throw new Error(\"The connection was stopped during negotiation.\");\n            }\n\n            if (negotiateResponse.error) {\n              throw new Error(negotiateResponse.error);\n            }\n\n            if (negotiateResponse.ProtocolVersion) {\n              throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n            }\n\n            if (negotiateResponse.url) {\n              url = negotiateResponse.url;\n            }\n\n            if (negotiateResponse.accessToken) {\n              // Replace the current access token factory with one that uses\n              // the returned access token\n              const accessToken = negotiateResponse.accessToken;\n\n              _this4._accessTokenFactory = () => accessToken;\n            }\n\n            redirects++;\n          } while (negotiateResponse.url && redirects < MAX_REDIRECTS);\n\n          if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n            throw new Error(\"Negotiate redirection limit exceeded.\");\n          }\n\n          yield _this4._createTransport(url, _this4._options.transport, negotiateResponse, transferFormat);\n        }\n\n        if (_this4.transport instanceof LongPollingTransport) {\n          _this4.features.inherentKeepAlive = true;\n        }\n\n        if (_this4._connectionState === \"Connecting\"\n        /* Connecting */\n        ) {\n          // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\n          // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\n          _this4._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\n\n          _this4._connectionState = \"Connected\"\n          /* Connected */\n          ;\n        } // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\n        // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\n        // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\n\n      } catch (e) {\n        _this4._logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\n\n        _this4._connectionState = \"Disconnected\"\n        /* Disconnected */\n        ;\n        _this4.transport = undefined; // if start fails, any active calls to stop assume that start will complete the stop promise\n\n        _this4._stopPromiseResolver();\n\n        return Promise.reject(e);\n      }\n    })();\n  }\n\n  _getNegotiationResponse(url) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const headers = {};\n\n      if (_this5._accessTokenFactory) {\n        const token = yield _this5._accessTokenFactory();\n\n        if (token) {\n          headers[HeaderNames.Authorization] = `Bearer ${token}`;\n        }\n      }\n\n      const [name, value] = getUserAgentHeader();\n      headers[name] = value;\n\n      const negotiateUrl = _this5._resolveNegotiateUrl(url);\n\n      _this5._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\n\n      try {\n        const response = yield _this5._httpClient.post(negotiateUrl, {\n          content: \"\",\n          headers: { ...headers,\n            ..._this5._options.headers\n          },\n          timeout: _this5._options.timeout,\n          withCredentials: _this5._options.withCredentials\n        });\n\n        if (response.statusCode !== 200) {\n          return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\n        }\n\n        const negotiateResponse = JSON.parse(response.content);\n\n        if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\n          // Negotiate version 0 doesn't use connectionToken\n          // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\n          negotiateResponse.connectionToken = negotiateResponse.connectionId;\n        }\n\n        return negotiateResponse;\n      } catch (e) {\n        let errorMessage = \"Failed to complete negotiation with the server: \" + e;\n\n        if (e instanceof HttpError) {\n          if (e.statusCode === 404) {\n            errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\n          }\n        }\n\n        _this5._logger.log(LogLevel.Error, errorMessage);\n\n        return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));\n      }\n    })();\n  }\n\n  _createConnectUrl(url, connectionToken) {\n    if (!connectionToken) {\n      return url;\n    }\n\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\n  }\n\n  _createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      let connectUrl = _this6._createConnectUrl(url, negotiateResponse.connectionToken);\n\n      if (_this6._isITransport(requestedTransport)) {\n        _this6._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n\n        _this6.transport = requestedTransport;\n        yield _this6._startTransport(connectUrl, requestedTransferFormat);\n        _this6.connectionId = negotiateResponse.connectionId;\n        return;\n      }\n\n      const transportExceptions = [];\n      const transports = negotiateResponse.availableTransports || [];\n      let negotiate = negotiateResponse;\n\n      for (const endpoint of transports) {\n        const transportOrError = _this6._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\n\n        if (transportOrError instanceof Error) {\n          // Store the error and continue, we don't want to cause a re-negotiate in these cases\n          transportExceptions.push(`${endpoint.transport} failed:`);\n          transportExceptions.push(transportOrError);\n        } else if (_this6._isITransport(transportOrError)) {\n          _this6.transport = transportOrError;\n\n          if (!negotiate) {\n            try {\n              negotiate = yield _this6._getNegotiationResponse(url);\n            } catch (ex) {\n              return Promise.reject(ex);\n            }\n\n            connectUrl = _this6._createConnectUrl(url, negotiate.connectionToken);\n          }\n\n          try {\n            yield _this6._startTransport(connectUrl, requestedTransferFormat);\n            _this6.connectionId = negotiate.connectionId;\n            return;\n          } catch (ex) {\n            _this6._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\n\n            negotiate = undefined;\n            transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));\n\n            if (_this6._connectionState !== \"Connecting\"\n            /* Connecting */\n            ) {\n              const message = \"Failed to select transport before stop() was called.\";\n\n              _this6._logger.log(LogLevel.Debug, message);\n\n              return Promise.reject(new Error(message));\n            }\n          }\n        }\n      }\n\n      if (transportExceptions.length > 0) {\n        return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\n      }\n\n      return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\n    })();\n  }\n\n  _constructTransport(transport) {\n    switch (transport) {\n      case HttpTransportType.WebSockets:\n        if (!this._options.WebSocket) {\n          throw new Error(\"'WebSocket' is not supported in your environment.\");\n        }\n\n        return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});\n\n      case HttpTransportType.ServerSentEvents:\n        if (!this._options.EventSource) {\n          throw new Error(\"'EventSource' is not supported in your environment.\");\n        }\n\n        return new ServerSentEventsTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options);\n\n      case HttpTransportType.LongPolling:\n        return new LongPollingTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options);\n\n      default:\n        throw new Error(`Unknown transport: ${transport}.`);\n    }\n  }\n\n  _startTransport(url, transferFormat) {\n    this.transport.onreceive = this.onreceive;\n\n    this.transport.onclose = e => this._stopConnection(e);\n\n    return this.transport.connect(url, transferFormat);\n  }\n\n  _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat) {\n    const transport = HttpTransportType[endpoint.transport];\n\n    if (transport === null || transport === undefined) {\n      this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\n\n      return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\n    } else {\n      if (transportMatches(requestedTransport, transport)) {\n        const transferFormats = endpoint.transferFormats.map(s => TransferFormat[s]);\n\n        if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n          if (transport === HttpTransportType.WebSockets && !this._options.WebSocket || transport === HttpTransportType.ServerSentEvents && !this._options.EventSource) {\n            this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\n\n            return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);\n          } else {\n            this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\n\n            try {\n              return this._constructTransport(transport);\n            } catch (ex) {\n              return ex;\n            }\n          }\n        } else {\n          this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\n\n          return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\n        }\n      } else {\n        this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\n\n        return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);\n      }\n    }\n  }\n\n  _isITransport(transport) {\n    return transport && typeof transport === \"object\" && \"connect\" in transport;\n  }\n\n  _stopConnection(error) {\n    this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\n\n    this.transport = undefined; // If we have a stopError, it takes precedence over the error from the transport\n\n    error = this._stopError || error;\n    this._stopError = undefined;\n\n    if (this._connectionState === \"Disconnected\"\n    /* Disconnected */\n    ) {\n      this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\n\n      return;\n    }\n\n    if (this._connectionState === \"Connecting\"\n    /* Connecting */\n    ) {\n      this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\n\n      throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\n    }\n\n    if (this._connectionState === \"Disconnecting\"\n    /* Disconnecting */\n    ) {\n      // A call to stop() induced this call to stopConnection and needs to be completed.\n      // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\n      this._stopPromiseResolver();\n    }\n\n    if (error) {\n      this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\n    } else {\n      this._logger.log(LogLevel.Information, \"Connection disconnected.\");\n    }\n\n    if (this._sendQueue) {\n      this._sendQueue.stop().catch(e => {\n        this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\n      });\n\n      this._sendQueue = undefined;\n    }\n\n    this.connectionId = undefined;\n    this._connectionState = \"Disconnected\"\n    /* Disconnected */\n    ;\n\n    if (this._connectionStarted) {\n      this._connectionStarted = false;\n\n      try {\n        if (this.onclose) {\n          this.onclose(error);\n        }\n      } catch (e) {\n        this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\n      }\n    }\n  }\n\n  _resolveUrl(url) {\n    // startsWith is not supported in IE\n    if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n      return url;\n    }\n\n    if (!Platform.isBrowser) {\n      throw new Error(`Cannot resolve '${url}'.`);\n    } // Setting the url to the href propery of an anchor tag handles normalization\n    // for us. There are 3 main cases.\n    // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n    // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n    // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n\n\n    const aTag = window.document.createElement(\"a\");\n    aTag.href = url;\n\n    this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\n\n    return aTag.href;\n  }\n\n  _resolveNegotiateUrl(url) {\n    const index = url.indexOf(\"?\");\n    let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n\n    if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n      negotiateUrl += \"/\";\n    }\n\n    negotiateUrl += \"negotiate\";\n    negotiateUrl += index === -1 ? \"\" : url.substring(index);\n\n    if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\n      negotiateUrl += index === -1 ? \"?\" : \"&\";\n      negotiateUrl += \"negotiateVersion=\" + this._negotiateVersion;\n    }\n\n    return negotiateUrl;\n  }\n\n}\n\nfunction transportMatches(requestedTransport, actualTransport) {\n  return !requestedTransport || (actualTransport & requestedTransport) !== 0;\n}\n/** @private */\n\n\nexport class TransportSendQueue {\n  constructor(_transport) {\n    this._transport = _transport;\n    this._buffer = [];\n    this._executing = true;\n    this._sendBufferedData = new PromiseSource();\n    this._transportResult = new PromiseSource();\n    this._sendLoopPromise = this._sendLoop();\n  }\n\n  send(data) {\n    this._bufferData(data);\n\n    if (!this._transportResult) {\n      this._transportResult = new PromiseSource();\n    }\n\n    return this._transportResult.promise;\n  }\n\n  stop() {\n    this._executing = false;\n\n    this._sendBufferedData.resolve();\n\n    return this._sendLoopPromise;\n  }\n\n  _bufferData(data) {\n    if (this._buffer.length && typeof this._buffer[0] !== typeof data) {\n      throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof data}`);\n    }\n\n    this._buffer.push(data);\n\n    this._sendBufferedData.resolve();\n  }\n\n  _sendLoop() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      while (true) {\n        yield _this7._sendBufferedData.promise;\n\n        if (!_this7._executing) {\n          if (_this7._transportResult) {\n            _this7._transportResult.reject(\"Connection stopped.\");\n          }\n\n          break;\n        }\n\n        _this7._sendBufferedData = new PromiseSource();\n        const transportResult = _this7._transportResult;\n        _this7._transportResult = undefined;\n        const data = typeof _this7._buffer[0] === \"string\" ? _this7._buffer.join(\"\") : TransportSendQueue._concatBuffers(_this7._buffer);\n        _this7._buffer.length = 0;\n\n        try {\n          yield _this7._transport.send(data);\n          transportResult.resolve();\n        } catch (error) {\n          transportResult.reject(error);\n        }\n      }\n    })();\n  }\n\n  static _concatBuffers(arrayBuffers) {\n    const totalLength = arrayBuffers.map(b => b.byteLength).reduce((a, b) => a + b);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n\n    for (const item of arrayBuffers) {\n      result.set(new Uint8Array(item), offset);\n      offset += item.byteLength;\n    }\n\n    return result.buffer;\n  }\n\n}\n\nclass PromiseSource {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\n  }\n\n  resolve() {\n    this._resolver();\n  }\n\n  reject(reason) {\n    this._rejecter(reason);\n  }\n\n} //# sourceMappingURL=HttpConnection.js.map","map":null,"metadata":{},"sourceType":"module"}