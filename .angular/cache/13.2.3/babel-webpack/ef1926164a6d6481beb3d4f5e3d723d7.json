{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Development\\\\Fun\\\\ArchaicQuest-II-Web-Client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { Platform, getGlobalThis } from \"./Utils\";\nexport class FetchHttpClient extends HttpClient {\n  constructor(logger) {\n    super();\n    this._logger = logger;\n\n    if (typeof fetch === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n\n      this._jar = new (requireFunc(\"tough-cookie\").CookieJar)();\n      this._fetchType = requireFunc(\"node-fetch\"); // node-fetch doesn't have a nice API for getting and setting cookies\n      // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n\n      this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\n    } else {\n      this._fetchType = fetch.bind(getGlobalThis());\n    }\n\n    if (typeof AbortController === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n\n      this._abortControllerType = requireFunc(\"abort-controller\");\n    } else {\n      this._abortControllerType = AbortController;\n    }\n  }\n  /** @inheritDoc */\n\n\n  send(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // Check that abort was not signaled before calling send\n      if (request.abortSignal && request.abortSignal.aborted) {\n        throw new AbortError();\n      }\n\n      if (!request.method) {\n        throw new Error(\"No method defined.\");\n      }\n\n      if (!request.url) {\n        throw new Error(\"No url defined.\");\n      }\n\n      const abortController = new _this._abortControllerType();\n      let error; // Hook our abortSignal into the abort controller\n\n      if (request.abortSignal) {\n        request.abortSignal.onabort = () => {\n          abortController.abort();\n          error = new AbortError();\n        };\n      } // If a timeout has been passed in, setup a timeout to call abort\n      // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\n\n\n      let timeoutId = null;\n\n      if (request.timeout) {\n        const msTimeout = request.timeout;\n        timeoutId = setTimeout(() => {\n          abortController.abort();\n\n          _this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\n\n          error = new TimeoutError();\n        }, msTimeout);\n      }\n\n      let response;\n\n      try {\n        response = yield _this._fetchType(request.url, {\n          body: request.content,\n          cache: \"no-cache\",\n          credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n          headers: {\n            \"Content-Type\": \"text/plain;charset=UTF-8\",\n            \"X-Requested-With\": \"XMLHttpRequest\",\n            ...request.headers\n          },\n          method: request.method,\n          mode: \"cors\",\n          redirect: \"follow\",\n          signal: abortController.signal\n        });\n      } catch (e) {\n        if (error) {\n          throw error;\n        }\n\n        _this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);\n\n        throw e;\n      } finally {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n\n        if (request.abortSignal) {\n          request.abortSignal.onabort = null;\n        }\n      }\n\n      if (!response.ok) {\n        const errorMessage = yield deserializeContent(response, \"text\");\n        throw new HttpError(errorMessage || response.statusText, response.status);\n      }\n\n      const content = deserializeContent(response, request.responseType);\n      const payload = yield content;\n      return new HttpResponse(response.status, response.statusText, payload);\n    })();\n  }\n\n  getCookieString(url) {\n    let cookies = \"\";\n\n    if (Platform.isNode && this._jar) {\n      // @ts-ignore: unused variable\n      this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\n    }\n\n    return cookies;\n  }\n\n}\n\nfunction deserializeContent(response, responseType) {\n  let content;\n\n  switch (responseType) {\n    case \"arraybuffer\":\n      content = response.arrayBuffer();\n      break;\n\n    case \"text\":\n      content = response.text();\n      break;\n\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(`${responseType} is not supported.`);\n\n    default:\n      content = response.text();\n      break;\n  }\n\n  return content;\n} //# sourceMappingURL=FetchHttpClient.js.map","map":null,"metadata":{},"sourceType":"module"}