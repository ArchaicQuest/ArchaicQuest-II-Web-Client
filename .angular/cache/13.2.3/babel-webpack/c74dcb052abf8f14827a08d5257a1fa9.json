{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rectangleCollidesWithQuad = exports.squareCollidesWithQuad = exports.getCircumscribedAlignedRectangle = exports.isRectangleAligned = void 0;\n/**\n * Sigma.js Quad Tree Class\n * =========================\n *\n * Class implementing the quad tree data structure used to solve hovers and\n * determine which elements are currently in the scope of the camera so that\n * we don't waste time rendering things the user cannot see anyway.\n * @module\n */\n\n/* eslint no-nested-ternary: 0 */\n\n/* eslint no-constant-condition: 0 */\n\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\")); // TODO: should not ask the quadtree when the camera has the whole graph in\n// sight.\n// TODO: a square can be represented as topleft + width, saying for the quad blocks (reduce mem)\n// TODO: jsdoc\n// TODO: be sure we can handle cases overcoming boundaries (because of size) or use a maxed size\n// TODO: filtering unwanted labels beforehand through the filter function\n// NOTE: this is basically a MX-CIF Quadtree at this point\n// NOTE: need to explore R-Trees for edges\n// NOTE: need to explore 2d segment tree for edges\n// NOTE: probably can do faster using spatial hashing\n\n/**\n * Constants.\n *\n * Note that since we are representing a static 4-ary tree, the indices of the\n * quadrants are the following:\n *   - TOP_LEFT:     4i + b\n *   - TOP_RIGHT:    4i + 2b\n *   - BOTTOM_LEFT:  4i + 3b\n *   - BOTTOM_RIGHT: 4i + 4b\n */\n\n\nvar BLOCKS = 4,\n    MAX_LEVEL = 5;\nvar OUTSIDE_BLOCK = \"outside\";\nvar X_OFFSET = 0,\n    Y_OFFSET = 1,\n    WIDTH_OFFSET = 2,\n    HEIGHT_OFFSET = 3;\nvar TOP_LEFT = 1,\n    TOP_RIGHT = 2,\n    BOTTOM_LEFT = 3,\n    BOTTOM_RIGHT = 4;\nvar hasWarnedTooMuchOutside = false;\n/**\n * Geometry helpers.\n */\n\n/**\n * Function returning whether the given rectangle is axis-aligned.\n *\n * @param  {Rectangle} rect\n * @return {boolean}\n */\n\nfunction isRectangleAligned(rect) {\n  return rect.x1 === rect.x2 || rect.y1 === rect.y2;\n}\n\nexports.isRectangleAligned = isRectangleAligned;\n/**\n * Function returning the smallest rectangle that contains the given rectangle, and that is aligned with the axis.\n *\n * @param {Rectangle} rect\n * @return {Rectangle}\n */\n\nfunction getCircumscribedAlignedRectangle(rect) {\n  var width = Math.sqrt(Math.pow(rect.x2 - rect.x1, 2) + Math.pow(rect.y2 - rect.y1, 2));\n  var heightVector = {\n    x: (rect.y1 - rect.y2) * rect.height / width,\n    y: (rect.x2 - rect.x1) * rect.height / width\n  }; // Compute all corners:\n\n  var tl = {\n    x: rect.x1,\n    y: rect.y1\n  };\n  var tr = {\n    x: rect.x2,\n    y: rect.y2\n  };\n  var bl = {\n    x: rect.x1 + heightVector.x,\n    y: rect.y1 + heightVector.y\n  };\n  var br = {\n    x: rect.x2 + heightVector.x,\n    y: rect.y2 + heightVector.y\n  };\n  var xL = Math.min(tl.x, tr.x, bl.x, br.x);\n  var xR = Math.max(tl.x, tr.x, bl.x, br.x);\n  var yT = Math.min(tl.y, tr.y, bl.y, br.y);\n  var yB = Math.max(tl.y, tr.y, bl.y, br.y);\n  return {\n    x1: xL,\n    y1: yT,\n    x2: xR,\n    y2: yT,\n    height: yB - yT\n  };\n}\n\nexports.getCircumscribedAlignedRectangle = getCircumscribedAlignedRectangle;\n/**\n *\n * @param x1\n * @param y1\n * @param w\n * @param qx\n * @param qy\n * @param qw\n * @param qh\n */\n\nfunction squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;\n}\n\nexports.squareCollidesWithQuad = squareCollidesWithQuad;\n\nfunction rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;\n}\n\nexports.rectangleCollidesWithQuad = rectangleCollidesWithQuad;\n\nfunction pointIsInQuad(x, y, qx, qy, qw, qh) {\n  var xmp = qx + qw / 2,\n      ymp = qy + qh / 2,\n      top = y < ymp,\n      left = x < xmp;\n  return top ? left ? TOP_LEFT : TOP_RIGHT : left ? BOTTOM_LEFT : BOTTOM_RIGHT;\n}\n/**\n * Helper functions that are not bound to the class so an external user\n * cannot mess with them.\n */\n\n\nfunction buildQuadrants(maxLevel, data) {\n  // [block, level]\n  var stack = [0, 0];\n\n  while (stack.length) {\n    var level = stack.pop(),\n        block = stack.pop();\n    var topLeftBlock = 4 * block + BLOCKS,\n        topRightBlock = 4 * block + 2 * BLOCKS,\n        bottomLeftBlock = 4 * block + 3 * BLOCKS,\n        bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var x = data[block + X_OFFSET],\n        y = data[block + Y_OFFSET],\n        width = data[block + WIDTH_OFFSET],\n        height = data[block + HEIGHT_OFFSET],\n        hw = width / 2,\n        hh = height / 2;\n    data[topLeftBlock + X_OFFSET] = x;\n    data[topLeftBlock + Y_OFFSET] = y;\n    data[topLeftBlock + WIDTH_OFFSET] = hw;\n    data[topLeftBlock + HEIGHT_OFFSET] = hh;\n    data[topRightBlock + X_OFFSET] = x + hw;\n    data[topRightBlock + Y_OFFSET] = y;\n    data[topRightBlock + WIDTH_OFFSET] = hw;\n    data[topRightBlock + HEIGHT_OFFSET] = hh;\n    data[bottomLeftBlock + X_OFFSET] = x;\n    data[bottomLeftBlock + Y_OFFSET] = y + hh;\n    data[bottomLeftBlock + WIDTH_OFFSET] = hw;\n    data[bottomLeftBlock + HEIGHT_OFFSET] = hh;\n    data[bottomRightBlock + X_OFFSET] = x + hw;\n    data[bottomRightBlock + Y_OFFSET] = y + hh;\n    data[bottomRightBlock + WIDTH_OFFSET] = hw;\n    data[bottomRightBlock + HEIGHT_OFFSET] = hh;\n\n    if (level < maxLevel - 1) {\n      stack.push(bottomRightBlock, level + 1);\n      stack.push(bottomLeftBlock, level + 1);\n      stack.push(topRightBlock, level + 1);\n      stack.push(topLeftBlock, level + 1);\n    }\n  }\n}\n\nfunction insertNode(maxLevel, data, containers, key, x, y, size) {\n  var x1 = x - size,\n      y1 = y - size,\n      w = size * 2;\n  var level = 0,\n      block = 0;\n\n  while (true) {\n    // If we reached max level\n    if (level >= maxLevel) {\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    }\n\n    var topLeftBlock = 4 * block + BLOCKS,\n        topRightBlock = 4 * block + 2 * BLOCKS,\n        bottomLeftBlock = 4 * block + 3 * BLOCKS,\n        bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    var collisions = [collidingWithTopLeft, collidingWithTopRight, collidingWithBottomLeft, collidingWithBottomRight].reduce(function (acc, current) {\n      if (current) return acc + 1;else return acc;\n    }, 0); // If we have no collision at root level, inject node in the outside block\n\n    if (collisions === 0 && level === 0) {\n      containers[OUTSIDE_BLOCK].push(key);\n\n      if (!hasWarnedTooMuchOutside && containers[OUTSIDE_BLOCK].length >= 5) {\n        hasWarnedTooMuchOutside = true;\n        console.warn(\"sigma/quadtree.insertNode: At least 5 nodes are outside the global quadtree zone. \" + \"You might have a problem with the normalization function or the custom bounding box.\");\n      }\n\n      return;\n    } // If we don't have at least a collision but deeper, there is an issue\n\n\n    if (collisions === 0) throw new Error(\"sigma/quadtree.insertNode: no collision (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\")); // If we have 3 collisions, we have a geometry problem obviously\n\n    if (collisions === 3) throw new Error(\"sigma/quadtree.insertNode: 3 impossible collisions (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\")); // If we have more that one collision, we stop here and store the node\n    // in the relevant containers\n\n    if (collisions > 1) {\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    } else {\n      level++;\n    } // Else we recurse into the correct quads\n\n\n    if (collidingWithTopLeft) block = topLeftBlock;\n    if (collidingWithTopRight) block = topRightBlock;\n    if (collidingWithBottomLeft) block = bottomLeftBlock;\n    if (collidingWithBottomRight) block = bottomRightBlock;\n  }\n}\n\nfunction getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {\n  // [block, level]\n  var stack = [0, 0];\n  var collectedNodes = [];\n  var container;\n\n  while (stack.length) {\n    var level = stack.pop(),\n        block = stack.pop(); // Collecting nodes\n\n    container = containers[block];\n    if (container) (0, extend_1.default)(collectedNodes, container); // If we reached max level\n\n    if (level >= maxLevel) continue;\n    var topLeftBlock = 4 * block + BLOCKS,\n        topRightBlock = 4 * block + 2 * BLOCKS,\n        bottomLeftBlock = 4 * block + 3 * BLOCKS,\n        bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    if (collidingWithTopLeft) stack.push(topLeftBlock, level + 1);\n    if (collidingWithTopRight) stack.push(topRightBlock, level + 1);\n    if (collidingWithBottomLeft) stack.push(bottomLeftBlock, level + 1);\n    if (collidingWithBottomRight) stack.push(bottomRightBlock, level + 1);\n  }\n\n  return collectedNodes;\n}\n/**\n * QuadTree class.\n *\n * @constructor\n * @param {object} boundaries - The graph boundaries.\n */\n\n\nvar QuadTree =\n/** @class */\nfunction () {\n  function QuadTree(params) {\n    var _a;\n\n    if (params === void 0) {\n      params = {};\n    }\n\n    this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n    this.cache = null;\n    this.lastRectangle = null; // Allocating the underlying byte array\n\n    var L = Math.pow(4, MAX_LEVEL);\n    this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));\n    if (params.boundaries) this.resize(params.boundaries);else this.resize({\n      x: 0,\n      y: 0,\n      width: 1,\n      height: 1\n    });\n  }\n\n  QuadTree.prototype.add = function (key, x, y, size) {\n    insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);\n    return this;\n  };\n\n  QuadTree.prototype.resize = function (boundaries) {\n    this.clear(); // Building the quadrants\n\n    this.data[X_OFFSET] = boundaries.x;\n    this.data[Y_OFFSET] = boundaries.y;\n    this.data[WIDTH_OFFSET] = boundaries.width;\n    this.data[HEIGHT_OFFSET] = boundaries.height;\n    buildQuadrants(MAX_LEVEL, this.data);\n  };\n\n  QuadTree.prototype.clear = function () {\n    var _a;\n\n    this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n    return this;\n  };\n\n  QuadTree.prototype.point = function (x, y) {\n    var nodes = this.containers[OUTSIDE_BLOCK];\n    var block = 0,\n        level = 0;\n\n    do {\n      if (this.containers[block]) nodes.push.apply(nodes, __spreadArray([], __read(this.containers[block]), false));\n      var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);\n      block = 4 * block + quad * BLOCKS;\n      level++;\n    } while (level <= MAX_LEVEL);\n\n    return nodes;\n  };\n\n  QuadTree.prototype.rectangle = function (x1, y1, x2, y2, height) {\n    var _a;\n\n    var lr = this.lastRectangle;\n\n    if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {\n      return this.cache;\n    }\n\n    this.lastRectangle = {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      height: height\n    }; // If the rectangle is shifted, we use the smallest aligned rectangle that contains the shifted one:\n\n    if (!isRectangleAligned(this.lastRectangle)) this.lastRectangle = getCircumscribedAlignedRectangle(this.lastRectangle);\n    this.cache = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height); // Add all the nodes in the outside block, since they might be relevant, and since they should be very few:\n\n    (_a = this.cache).push.apply(_a, __spreadArray([], __read(this.containers[OUTSIDE_BLOCK]), false));\n\n    return this.cache;\n  };\n\n  return QuadTree;\n}();\n\nexports.default = QuadTree;","map":null,"metadata":{},"sourceType":"script"}