{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Development\\\\Fun\\\\ArchaicQuest-II-Web-Client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HeaderNames } from \"./HeaderNames\";\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\n/** @private */\n\nexport class WebSocketTransport {\n  constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\n    this._logger = logger;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logMessageContent = logMessageContent;\n    this._webSocketConstructor = webSocketConstructor;\n    this._httpClient = httpClient;\n    this.onreceive = null;\n    this.onclose = null;\n    this._headers = headers;\n  }\n\n  connect(url, transferFormat) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      Arg.isRequired(url, \"url\");\n      Arg.isRequired(transferFormat, \"transferFormat\");\n      Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n\n      _this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\n\n      if (_this._accessTokenFactory) {\n        const token = yield _this._accessTokenFactory();\n\n        if (token) {\n          url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\n        }\n      }\n\n      return new Promise((resolve, reject) => {\n        url = url.replace(/^http/, \"ws\");\n        let webSocket;\n\n        const cookies = _this._httpClient.getCookieString(url);\n\n        let opened = false;\n\n        if (Platform.isNode) {\n          const headers = {};\n          const [name, value] = getUserAgentHeader();\n          headers[name] = value;\n\n          if (cookies) {\n            headers[HeaderNames.Cookie] = `${cookies}`;\n          } // Only pass headers when in non-browser environments\n\n\n          webSocket = new _this._webSocketConstructor(url, undefined, {\n            headers: { ...headers,\n              ..._this._headers\n            }\n          });\n        }\n\n        if (!webSocket) {\n          // Chrome is not happy with passing 'undefined' as protocol\n          webSocket = new _this._webSocketConstructor(url);\n        }\n\n        if (transferFormat === TransferFormat.Binary) {\n          webSocket.binaryType = \"arraybuffer\";\n        }\n\n        webSocket.onopen = _event => {\n          _this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\n\n          _this._webSocket = webSocket;\n          opened = true;\n          resolve();\n        };\n\n        webSocket.onerror = event => {\n          let error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n          if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n            error = event.error;\n          } else {\n            error = \"There was an error with the transport\";\n          }\n\n          _this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\n        };\n\n        webSocket.onmessage = message => {\n          _this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, _this._logMessageContent)}.`);\n\n          if (_this.onreceive) {\n            try {\n              _this.onreceive(message.data);\n            } catch (error) {\n              _this._close(error);\n\n              return;\n            }\n          }\n        };\n\n        webSocket.onclose = event => {\n          // Don't call close handler if connection was never established\n          // We'll reject the connect call instead\n          if (opened) {\n            _this._close(event);\n          } else {\n            let error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n            if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n              error = event.error;\n            } else {\n              error = \"WebSocket failed to connect. The connection could not be found on the server,\" + \" either the endpoint may not be a SignalR endpoint,\" + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\" + \" If you have multiple servers check that sticky sessions are enabled.\";\n            }\n\n            reject(new Error(error));\n          }\n        };\n      });\n    })();\n  }\n\n  send(data) {\n    if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\n      this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\n\n      this._webSocket.send(data);\n\n      return Promise.resolve();\n    }\n\n    return Promise.reject(\"WebSocket is not in the OPEN state\");\n  }\n\n  stop() {\n    if (this._webSocket) {\n      // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n      // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n      this._close(undefined);\n    }\n\n    return Promise.resolve();\n  }\n\n  _close(event) {\n    // webSocket will be null if the transport did not start successfully\n    if (this._webSocket) {\n      // Clear websocket handlers because we are considering the socket closed now\n      this._webSocket.onclose = () => {};\n\n      this._webSocket.onmessage = () => {};\n\n      this._webSocket.onerror = () => {};\n\n      this._webSocket.close();\n\n      this._webSocket = undefined;\n    }\n\n    this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\n\n    if (this.onclose) {\n      if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n        this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\n      } else if (event instanceof Error) {\n        this.onclose(event);\n      } else {\n        this.onclose();\n      }\n    }\n  }\n\n  _isCloseEvent(event) {\n    return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n  }\n\n} //# sourceMappingURL=WebSocketTransport.js.map","map":null,"metadata":{},"sourceType":"module"}