{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Sigma.js Camera Class\n * ======================\n *\n * Class designed to store camera information & used to update it.\n * @module\n */\n\nvar animate_1 = require(\"../utils/animate\");\n\nvar easings_1 = __importDefault(require(\"../utils/easings\"));\n\nvar utils_1 = require(\"../utils\");\n\nvar types_1 = require(\"../types\");\n/**\n * Defaults.\n */\n\n\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n/**\n * Camera class\n *\n * @constructor\n */\n\nvar Camera =\n/** @class */\nfunction (_super) {\n  __extends(Camera, _super);\n\n  function Camera() {\n    var _this = _super.call(this) || this;\n\n    _this.x = 0.5;\n    _this.y = 0.5;\n    _this.angle = 0;\n    _this.ratio = 1;\n    _this.minRatio = null;\n    _this.maxRatio = null;\n    _this.nextFrame = null;\n    _this.previousState = null;\n    _this.enabled = true; // State\n\n    _this.previousState = _this.getState();\n    return _this;\n  }\n  /**\n   * Static method used to create a Camera object with a given state.\n   *\n   * @param state\n   * @return {Camera}\n   */\n\n\n  Camera.from = function (state) {\n    var camera = new Camera();\n    return camera.setState(state);\n  };\n  /**\n   * Method used to enable the camera.\n   *\n   * @return {Camera}\n   */\n\n\n  Camera.prototype.enable = function () {\n    this.enabled = true;\n    return this;\n  };\n  /**\n   * Method used to disable the camera.\n   *\n   * @return {Camera}\n   */\n\n\n  Camera.prototype.disable = function () {\n    this.enabled = false;\n    return this;\n  };\n  /**\n   * Method used to retrieve the camera's current state.\n   *\n   * @return {object}\n   */\n\n\n  Camera.prototype.getState = function () {\n    return {\n      x: this.x,\n      y: this.y,\n      angle: this.angle,\n      ratio: this.ratio\n    };\n  };\n  /**\n   * Method used to check whether the camera has the given state.\n   *\n   * @return {object}\n   */\n\n\n  Camera.prototype.hasState = function (state) {\n    return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n  };\n  /**\n   * Method used to retrieve the camera's previous state.\n   *\n   * @return {object}\n   */\n\n\n  Camera.prototype.getPreviousState = function () {\n    var state = this.previousState;\n    if (!state) return null;\n    return {\n      x: state.x,\n      y: state.y,\n      angle: state.angle,\n      ratio: state.ratio\n    };\n  };\n  /**\n   * Method used to check minRatio and maxRatio values.\n   *\n   * @param ratio\n   * @return {number}\n   */\n\n\n  Camera.prototype.getBoundedRatio = function (ratio) {\n    var r = ratio;\n    if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n    if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n    return r;\n  };\n  /**\n   * Method used to check various things to return a legit state candidate.\n   *\n   * @param state\n   * @return {object}\n   */\n\n\n  Camera.prototype.validateState = function (state) {\n    var validatedState = {};\n    if (typeof state.x === \"number\") validatedState.x = state.x;\n    if (typeof state.y === \"number\") validatedState.y = state.y;\n    if (typeof state.angle === \"number\") validatedState.angle = state.angle;\n    if (typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n    return validatedState;\n  };\n  /**\n   * Method used to check whether the camera is currently being animated.\n   *\n   * @return {boolean}\n   */\n\n\n  Camera.prototype.isAnimated = function () {\n    return !!this.nextFrame;\n  };\n  /**\n   * Method used to set the camera's state.\n   *\n   * @param  {object} state - New state.\n   * @return {Camera}\n   */\n\n\n  Camera.prototype.setState = function (state) {\n    if (!this.enabled) return this; // TODO: update by function\n    // Keeping track of last state\n\n    this.previousState = this.getState();\n    var validState = this.validateState(state);\n    if (typeof validState.x === \"number\") this.x = validState.x;\n    if (typeof validState.y === \"number\") this.y = validState.y;\n    if (typeof validState.angle === \"number\") this.angle = validState.angle;\n    if (typeof validState.ratio === \"number\") this.ratio = validState.ratio; // Emitting\n\n    if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n    return this;\n  };\n  /**\n   * Method used to animate the camera.\n   *\n   * @param  {object}                    state      - State to reach eventually.\n   * @param  {object}                    opts       - Options:\n   * @param  {number}                      duration - Duration of the animation.\n   * @param  {string | number => number}   easing   - Easing function or name of an existing one\n   * @param  {function}                  callback   - Callback\n   */\n\n\n  Camera.prototype.animate = function (state, opts, callback) {\n    var _this = this;\n\n    if (!this.enabled) return;\n    var options = Object.assign({}, animate_1.ANIMATE_DEFAULTS, opts);\n    var validState = this.validateState(state);\n    var easing = typeof options.easing === \"function\" ? options.easing : easings_1.default[options.easing]; // State\n\n    var start = Date.now(),\n        initialState = this.getState(); // Function performing the animation\n\n    var fn = function () {\n      var t = (Date.now() - start) / options.duration; // The animation is over:\n\n      if (t >= 1) {\n        _this.nextFrame = null;\n\n        _this.setState(validState);\n\n        if (_this.animationCallback) {\n          _this.animationCallback.call(null);\n\n          _this.animationCallback = undefined;\n        }\n\n        return;\n      }\n\n      var coefficient = easing(t);\n      var newState = {};\n      if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n      if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n      if (typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n      if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n\n      _this.setState(newState);\n\n      _this.nextFrame = (0, utils_1.requestFrame)(fn);\n    };\n\n    if (this.nextFrame) {\n      (0, utils_1.cancelFrame)(this.nextFrame);\n      if (this.animationCallback) this.animationCallback.call(null);\n      this.nextFrame = (0, utils_1.requestFrame)(fn);\n    } else {\n      fn();\n    }\n\n    this.animationCallback = callback;\n  };\n  /**\n   * Method used to zoom the camera.\n   *\n   * @param  {number|object} factorOrOptions - Factor or options.\n   * @return {function}\n   */\n\n\n  Camera.prototype.animatedZoom = function (factorOrOptions) {\n    if (!factorOrOptions) {\n      this.animate({\n        ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n      });\n    } else {\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio / factorOrOptions\n      });else this.animate({\n        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n  };\n  /**\n   * Method used to unzoom the camera.\n   *\n   * @param  {number|object} factorOrOptions - Factor or options.\n   */\n\n\n  Camera.prototype.animatedUnzoom = function (factorOrOptions) {\n    if (!factorOrOptions) {\n      this.animate({\n        ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n      });\n    } else {\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio * factorOrOptions\n      });else this.animate({\n        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n  };\n  /**\n   * Method used to reset the camera.\n   *\n   * @param  {object} options - Options.\n   */\n\n\n  Camera.prototype.animatedReset = function (options) {\n    this.animate({\n      x: 0.5,\n      y: 0.5,\n      ratio: 1,\n      angle: 0\n    }, options);\n  };\n  /**\n   * Returns a new Camera instance, with the same state as the current camera.\n   *\n   * @return {Camera}\n   */\n\n\n  Camera.prototype.copy = function () {\n    return Camera.from(this.getState());\n  };\n\n  return Camera;\n}(types_1.TypedEventEmitter);\n\nexports.default = Camera;","map":null,"metadata":{},"sourceType":"script"}