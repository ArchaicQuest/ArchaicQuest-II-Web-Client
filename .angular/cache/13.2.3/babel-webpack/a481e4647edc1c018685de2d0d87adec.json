{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { AbortError } from \"./Errors\";\nimport { FetchHttpClient } from \"./FetchHttpClient\";\nimport { HttpClient } from \"./HttpClient\";\nimport { Platform } from \"./Utils\";\nimport { XhrHttpClient } from \"./XhrHttpClient\";\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\n\nexport class DefaultHttpClient extends HttpClient {\n  /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\n  constructor(logger) {\n    super();\n\n    if (typeof fetch !== \"undefined\" || Platform.isNode) {\n      this._httpClient = new FetchHttpClient(logger);\n    } else if (typeof XMLHttpRequest !== \"undefined\") {\n      this._httpClient = new XhrHttpClient(logger);\n    } else {\n      throw new Error(\"No usable HttpClient found.\");\n    }\n  }\n  /** @inheritDoc */\n\n\n  send(request) {\n    // Check that abort was not signaled before calling send\n    if (request.abortSignal && request.abortSignal.aborted) {\n      return Promise.reject(new AbortError());\n    }\n\n    if (!request.method) {\n      return Promise.reject(new Error(\"No method defined.\"));\n    }\n\n    if (!request.url) {\n      return Promise.reject(new Error(\"No url defined.\"));\n    }\n\n    return this._httpClient.send(request);\n  }\n\n  getCookieString(url) {\n    return this._httpClient.getCookieString(url);\n  }\n\n} //# sourceMappingURL=DefaultHttpClient.js.map","map":null,"metadata":{},"sourceType":"module"}