{"ast":null,"code":"(() => {\n  \"use strict\";\n\n  var o = {\n    d: (t, e) => {\n      for (var n in e) o.o(e, n) && !o.o(t, n) && Object.defineProperty(t, n, {\n        enumerable: !0,\n        get: e[n]\n      });\n    },\n    o: (o, t) => Object.prototype.hasOwnProperty.call(o, t),\n    r: o => {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(o, \"__esModule\", {\n        value: !0\n      });\n    }\n  },\n      t = {};\n  o.r(t), o.d(t, {\n    default: () => e\n  });\n  const e = \"attribute vec2 a_position;\\nattribute float a_size;\\nattribute vec4 a_color;\\n\\nuniform float u_ratio;\\nuniform float u_scale;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\\n\\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\";\n  module.exports = t;\n})();","map":null,"metadata":{},"sourceType":"script"}