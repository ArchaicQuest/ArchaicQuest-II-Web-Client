{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar camera_1 = __importDefault(require(\"./core/camera\"));\n\nvar mouse_1 = __importDefault(require(\"./core/captors/mouse\"));\n\nvar quadtree_1 = __importDefault(require(\"./core/quadtree\"));\n\nvar types_1 = require(\"./types\");\n\nvar utils_1 = require(\"./utils\");\n\nvar labels_1 = require(\"./core/labels\");\n\nvar settings_1 = require(\"./settings\");\n\nvar touch_1 = __importDefault(require(\"./core/captors/touch\"));\n\nvar matrices_1 = require(\"./utils/matrices\");\n\nvar edge_collisions_1 = require(\"./utils/edge-collisions\");\n/**\n * Constants.\n */\n\n\nvar PIXEL_RATIO = (0, utils_1.getPixelRatio)();\n/**\n * Important functions.\n */\n\nfunction applyNodeDefaults(settings, key, data) {\n  if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n  if (!data.hasOwnProperty(\"highlighted\")) data.highlighted = false;\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\nfunction applyEdgeDefaults(settings, key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\n\n\nvar Sigma =\n/** @class */\nfunction (_super) {\n  __extends(Sigma, _super);\n\n  function Sigma(graph, container, settings) {\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.elements = {};\n    _this.canvasContexts = {};\n    _this.webGLContexts = {};\n    _this.activeListeners = {};\n    _this.quadtree = new quadtree_1.default();\n    _this.labelGrid = new labels_1.LabelGrid();\n    _this.nodeDataCache = {};\n    _this.edgeDataCache = {};\n    _this.nodesWithForcedLabels = [];\n    _this.edgesWithForcedLabels = [];\n    _this.nodeKeyToIndex = {};\n    _this.edgeKeyToIndex = {};\n    _this.nodeExtent = {\n      x: [0, 1],\n      y: [0, 1]\n    };\n    _this.matrix = (0, matrices_1.identity)();\n    _this.invMatrix = (0, matrices_1.identity)();\n    _this.correctionRatio = 1;\n    _this.customBBox = null;\n    _this.normalizationFunction = (0, utils_1.createNormalizationFunction)({\n      x: [-Infinity, Infinity],\n      y: [-Infinity, Infinity]\n    }); // Cache:\n\n    _this.cameraSizeRatio = 1; // Starting dimensions\n\n    _this.width = 0;\n    _this.height = 0; // State\n\n    _this.displayedLabels = new Set();\n    _this.highlightedNodes = new Set();\n    _this.hoveredNode = null;\n    _this.hoveredEdge = null;\n    _this.renderFrame = null;\n    _this.renderHighlightedNodesFrame = null;\n    _this.needToProcess = false;\n    _this.needToSoftProcess = false;\n    _this.checkEdgesEventsFrame = null; // Programs\n\n    _this.nodePrograms = {};\n    _this.hoverNodePrograms = {};\n    _this.edgePrograms = {};\n    _this.settings = (0, utils_1.assign)({}, settings_1.DEFAULT_SETTINGS, settings); // Validating\n\n    (0, settings_1.validateSettings)(_this.settings);\n    (0, utils_1.validateGraph)(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\"); // Properties\n\n    _this.graph = graph;\n    _this.container = container;\n\n    _this.initializeCache(); // Initializing contexts\n\n\n    _this.createWebGLContext(\"edges\", {\n      preserveDrawingBuffer: true\n    });\n\n    _this.createCanvasContext(\"edgeLabels\");\n\n    _this.createWebGLContext(\"nodes\");\n\n    _this.createCanvasContext(\"labels\");\n\n    _this.createCanvasContext(\"hovers\");\n\n    _this.createWebGLContext(\"hoverNodes\");\n\n    _this.createCanvasContext(\"mouse\"); // Blending\n\n\n    for (var key in _this.webGLContexts) {\n      var gl = _this.webGLContexts[key];\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.enable(gl.BLEND);\n    } // Loading programs\n\n\n    for (var type in _this.settings.nodeProgramClasses) {\n      var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n      _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this);\n      _this.hoverNodePrograms[type] = new NodeProgramClass(_this.webGLContexts.hoverNodes, _this);\n    }\n\n    for (var type in _this.settings.edgeProgramClasses) {\n      var EdgeProgramClass = _this.settings.edgeProgramClasses[type];\n      _this.edgePrograms[type] = new EdgeProgramClass(_this.webGLContexts.edges, _this);\n    } // Initial resize\n\n\n    _this.resize(); // Initializing the camera\n\n\n    _this.camera = new camera_1.default(); // Binding camera events\n\n    _this.bindCameraHandlers(); // Initializing captors\n\n\n    _this.mouseCaptor = new mouse_1.default(_this.elements.mouse, _this);\n    _this.touchCaptor = new touch_1.default(_this.elements.mouse, _this); // Binding event handlers\n\n    _this.bindEventHandlers(); // Binding graph handlers\n\n\n    _this.bindGraphHandlers(); // Trigger eventual settings-related things\n\n\n    _this.handleSettingsUpdate(); // Processing data for the first time & render\n\n\n    _this.process();\n\n    _this.render();\n\n    return _this;\n  }\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to create a canvas element.\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.createCanvas = function (id) {\n    var canvas = (0, utils_1.createElement)(\"canvas\", {\n      position: \"absolute\"\n    }, {\n      class: \"sigma-\".concat(id)\n    });\n    this.elements[id] = canvas;\n    this.container.appendChild(canvas);\n    return canvas;\n  };\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.createCanvasContext = function (id) {\n    var canvas = this.createCanvas(id);\n    var contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false\n    };\n    this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n    return this;\n  };\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string}  id      - Context's id.\n   * @param  {object?} options - #getContext params to override (optional)\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.createWebGLContext = function (id, options) {\n    var canvas = this.createCanvas(id);\n\n    var contextOptions = __assign({\n      preserveDrawingBuffer: false,\n      antialias: false\n    }, options || {});\n\n    var context; // First we try webgl2 for an easy performance boost\n\n    context = canvas.getContext(\"webgl2\", contextOptions); // Else we fall back to webgl\n\n    if (!context) context = canvas.getContext(\"webgl\", contextOptions); // Edge, I am looking right at you...\n\n    if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n    this.webGLContexts[id] = context;\n    return this;\n  };\n  /**\n   * Method used to initialize display data cache.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.initializeCache = function () {\n    var _this = this;\n\n    var graph = this.graph; // NOTE: the data caches are never reset to avoid paying a GC cost\n    // But this could prove to be a bad decision. In which case just \"reset\"\n    // them here.\n\n    var i = 0;\n    graph.forEachNode(function (key) {\n      _this.nodeKeyToIndex[key] = i++;\n    });\n    i = 0;\n    graph.forEachEdge(function (key) {\n      _this.edgeKeyToIndex[key] = i++;\n    });\n  };\n  /**\n   * Method binding camera handlers.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.bindCameraHandlers = function () {\n    var _this = this;\n\n    this.activeListeners.camera = function () {\n      _this._scheduleRefresh();\n    };\n\n    this.camera.on(\"updated\", this.activeListeners.camera);\n    return this;\n  };\n  /**\n   * Method binding event handlers.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.bindEventHandlers = function () {\n    var _this = this; // Handling window resize\n\n\n    this.activeListeners.handleResize = function () {\n      _this.needToSoftProcess = true;\n\n      _this._scheduleRefresh();\n    };\n\n    window.addEventListener(\"resize\", this.activeListeners.handleResize); // Function checking if the mouse is on the given node\n\n    var mouseIsOnNode = function (mouseX, mouseY, nodeX, nodeY, size) {\n      return mouseX > nodeX - size && mouseX < nodeX + size && mouseY > nodeY - size && mouseY < nodeY + size && Math.sqrt(Math.pow(mouseX - nodeX, 2) + Math.pow(mouseY - nodeY, 2)) < size;\n    }; // Function returning the nodes in the mouse's quad\n\n\n    var getQuadNodes = function (mouseX, mouseY) {\n      var mouseGraphPosition = _this.viewportToFramedGraph({\n        x: mouseX,\n        y: mouseY\n      }); // TODO: minus 1? lol\n\n\n      return _this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n    }; // Handling mouse move\n\n\n    this.activeListeners.handleMove = function (e) {\n      // NOTE: for the canvas renderer, testing the pixel's alpha should\n      // give some boost but this slows things down for WebGL empirically.\n      var quadNodes = getQuadNodes(e.x, e.y);\n      var baseEvent = {\n        event: e,\n        preventSigmaDefault: function () {\n          this.event.preventSigmaDefault();\n        }\n      }; // We will hover the node whose center is closest to mouse\n\n      var minDistance = Infinity,\n          nodeToHover = null;\n\n      for (var i = 0, l = quadNodes.length; i < l; i++) {\n        var node = quadNodes[i];\n        var data = _this.nodeDataCache[node];\n\n        var pos = _this.framedGraphToViewport(data);\n\n        var size = _this.scaleSize(data.size);\n\n        if (!data.hidden && mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) {\n          var distance = Math.sqrt(Math.pow(e.x - pos.x, 2) + Math.pow(e.y - pos.y, 2)); // TODO: sort by min size also for cases where center is the same\n\n          if (distance < minDistance) {\n            minDistance = distance;\n            nodeToHover = node;\n          }\n        }\n      }\n\n      if (nodeToHover && _this.hoveredNode !== nodeToHover && !_this.nodeDataCache[nodeToHover].hidden) {\n        // Handling passing from one node to the other directly\n        if (_this.hoveredNode) _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), {\n          node: _this.hoveredNode\n        }));\n        _this.hoveredNode = nodeToHover;\n\n        _this.emit(\"enterNode\", __assign(__assign({}, baseEvent), {\n          node: nodeToHover\n        }));\n\n        _this.scheduleHighlightedNodesRender();\n\n        return;\n      } // Checking if the hovered node is still hovered\n\n\n      if (_this.hoveredNode) {\n        var data = _this.nodeDataCache[_this.hoveredNode];\n\n        var pos = _this.framedGraphToViewport(data);\n\n        var size = _this.scaleSize(data.size);\n\n        if (!mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) {\n          var node = _this.hoveredNode;\n          _this.hoveredNode = null;\n\n          _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), {\n            node: node\n          }));\n\n          return _this.scheduleHighlightedNodesRender();\n        }\n      }\n\n      if (_this.settings.enableEdgeHoverEvents === true) {\n        _this.checkEdgeHoverEvents(baseEvent);\n      } else if (_this.settings.enableEdgeHoverEvents === \"debounce\") {\n        if (!_this.checkEdgesEventsFrame) _this.checkEdgesEventsFrame = (0, utils_1.requestFrame)(function () {\n          _this.checkEdgeHoverEvents(baseEvent);\n\n          _this.checkEdgesEventsFrame = null;\n        });\n      }\n    }; // Handling click\n\n\n    var createMouseListener = function (eventType) {\n      return function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function () {\n            this.event.preventSigmaDefault();\n          }\n        };\n        if (_this.hoveredNode) return _this.emit(\"\".concat(eventType, \"Node\"), __assign(__assign({}, baseEvent), {\n          node: _this.hoveredNode\n        }));\n\n        if (eventType === \"wheel\" ? _this.settings.enableEdgeWheelEvents : _this.settings.enableEdgeClickEvents) {\n          var edge = _this.getEdgeAtPoint(e.x, e.y);\n\n          if (edge) return _this.emit(\"\".concat(eventType, \"Edge\"), __assign(__assign({}, baseEvent), {\n            edge: edge\n          }));\n        }\n\n        return _this.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n      };\n    };\n\n    this.activeListeners.handleClick = createMouseListener(\"click\");\n    this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n    this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n    this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n    this.activeListeners.handleDown = createMouseListener(\"down\");\n    this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n    this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n    this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n    this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n    this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n    this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown); // TODO\n    // Deal with Touch captor events\n\n    return this;\n  };\n  /**\n   * Method binding graph handlers\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.bindGraphHandlers = function () {\n    var _this = this;\n\n    var graph = this.graph;\n\n    this.activeListeners.graphUpdate = function () {\n      _this.needToProcess = true;\n\n      _this._scheduleRefresh();\n    };\n\n    this.activeListeners.softGraphUpdate = function () {\n      _this.needToSoftProcess = true;\n\n      _this._scheduleRefresh();\n    };\n\n    this.activeListeners.addNodeGraphUpdate = function (e) {\n      // Adding entry to cache\n      _this.nodeKeyToIndex[e.key] = graph.order - 1;\n\n      _this.activeListeners.graphUpdate();\n    };\n\n    this.activeListeners.addEdgeGraphUpdate = function (e) {\n      // Adding entry to cache\n      _this.nodeKeyToIndex[e.key] = graph.order - 1;\n\n      _this.activeListeners.graphUpdate();\n    }; // TODO: clean cache on drop!\n    // TODO: bind this on composed state events\n    // TODO: it could be possible to update only specific node etc. by holding\n    // a fixed-size pool of updated items\n\n\n    graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n    graph.on(\"nodeDropped\", this.activeListeners.graphUpdate);\n    graph.on(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n    graph.on(\"edgeDropped\", this.activeListeners.graphUpdate);\n    graph.on(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"edgesCleared\", this.activeListeners.graphUpdate);\n    graph.on(\"cleared\", this.activeListeners.graphUpdate);\n    return this;\n  };\n  /**\n   * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.checkEdgeHoverEvents = function (payload) {\n    var edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n\n    if (edgeToHover !== this.hoveredEdge) {\n      if (this.hoveredEdge) this.emit(\"leaveEdge\", __assign(__assign({}, payload), {\n        edge: this.hoveredEdge\n      }));\n      if (edgeToHover) this.emit(\"enterEdge\", __assign(__assign({}, payload), {\n        edge: edgeToHover\n      }));\n      this.hoveredEdge = edgeToHover;\n    }\n\n    return this;\n  };\n  /**\n   * Method looking for an edge colliding with a given point at (x, y). Returns\n   * the key of the edge if any, or null else.\n   */\n\n\n  Sigma.prototype.getEdgeAtPoint = function (x, y) {\n    var e_1, _a;\n\n    var _this = this;\n\n    var _b = this,\n        edgeDataCache = _b.edgeDataCache,\n        nodeDataCache = _b.nodeDataCache; // Check first that pixel is colored:\n    // Note that mouse positions must be corrected by pixel ratio to correctly\n    // index the drawing buffer.\n\n\n    if (!(0, edge_collisions_1.isPixelColored)(this.webGLContexts.edges, x * PIXEL_RATIO, y * PIXEL_RATIO)) return null; // Check for each edge if it collides with the point:\n\n    var _c = this.viewportToGraph({\n      x: x,\n      y: y\n    }),\n        graphX = _c.x,\n        graphY = _c.y; // To translate edge thicknesses to the graph system, we observe by how much\n    // the length of a non-null edge is transformed to between the graph system\n    // and the viewport system:\n\n\n    var transformationRatio = 0;\n    this.graph.someEdge(function (key, _, sourceId, targetId, _a, _b) {\n      var xs = _a.x,\n          ys = _a.y;\n      var xt = _b.x,\n          yt = _b.y;\n      if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden) return false;\n\n      if (xs !== xt || ys !== yt) {\n        var graphLength = Math.sqrt(Math.pow(xt - xs, 2) + Math.pow(yt - ys, 2));\n\n        var _c = _this.graphToViewport({\n          x: xs,\n          y: ys\n        }),\n            vp_xs = _c.x,\n            vp_ys = _c.y;\n\n        var _d = _this.graphToViewport({\n          x: xt,\n          y: yt\n        }),\n            vp_xt = _d.x,\n            vp_yt = _d.y;\n\n        var viewportLength = Math.sqrt(Math.pow(vp_xt - vp_xs, 2) + Math.pow(vp_yt - vp_ys, 2));\n        transformationRatio = graphLength / viewportLength;\n        return true;\n      }\n    }); // If no non-null edge has been found, return null:\n\n    if (!transformationRatio) return null; // Now we can look for matching edges:\n\n    var edges = this.graph.filterEdges(function (key, edgeAttributes, sourceId, targetId, sourcePosition, targetPosition) {\n      if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden) return false;\n\n      if ((0, edge_collisions_1.doEdgeCollideWithPoint)(graphX, graphY, sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y, // Adapt the edge size to the zoom ratio:\n      edgeDataCache[key].size * transformationRatio / _this.cameraSizeRatio)) {\n        return true;\n      }\n    });\n    if (edges.length === 0) return null; // no edges found\n    // if none of the edges have a zIndex, selected the most recently created one to match the rendering order\n\n    var selectedEdge = edges[edges.length - 1]; // otherwise select edge with highest zIndex\n\n    var highestZIndex = -Infinity;\n\n    try {\n      for (var edges_1 = __values(edges), edges_1_1 = edges_1.next(); !edges_1_1.done; edges_1_1 = edges_1.next()) {\n        var edge = edges_1_1.value;\n        var zIndex = this.graph.getEdgeAttribute(edge, \"zIndex\");\n\n        if (zIndex >= highestZIndex) {\n          selectedEdge = edge;\n          highestZIndex = zIndex;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (edges_1_1 && !edges_1_1.done && (_a = edges_1.return)) _a.call(edges_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return selectedEdge;\n  };\n  /**\n   * Method used to process the whole graph's data.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.process = function (keepArrays) {\n    var _this = this;\n\n    if (keepArrays === void 0) {\n      keepArrays = false;\n    }\n\n    var graph = this.graph;\n    var settings = this.settings;\n    var dimensions = this.getDimensions();\n    var nodeZExtent = [Infinity, -Infinity];\n    var edgeZExtent = [Infinity, -Infinity]; // Clearing the quad\n\n    this.quadtree.clear(); // Resetting the label grid\n    // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n\n    this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize); // Clear the highlightedNodes\n\n    this.highlightedNodes = new Set(); // Computing extents\n\n    this.nodeExtent = (0, utils_1.graphExtent)(graph); // Resetting `forceLabel` indices\n\n    this.nodesWithForcedLabels = [];\n    this.edgesWithForcedLabels = []; // NOTE: it is important to compute this matrix after computing the node's extent\n    // because #.getGraphDimensions relies on it\n\n    var nullCamera = new camera_1.default();\n    var nullCameraMatrix = (0, utils_1.matrixFromCamera)(nullCamera.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0); // Rescaling function\n\n    this.normalizationFunction = (0, utils_1.createNormalizationFunction)(this.customBBox || this.nodeExtent);\n    var nodesPerPrograms = {};\n    var nodes = graph.nodes();\n\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i]; // Node display data resolution:\n      //   1. First we get the node's attributes\n      //   2. We optionally reduce them using the function provided by the user\n      //      Note that this function must return a total object and won't be merged\n      //   3. We apply our defaults, while running some vital checks\n      //   4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n\n      var attr = Object.assign({}, graph.getNodeAttributes(node));\n      if (settings.nodeReducer) attr = settings.nodeReducer(node, attr);\n      var data = applyNodeDefaults(this.settings, node, attr);\n      nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      this.nodeDataCache[node] = data;\n      this.normalizationFunction.applyTo(data);\n      if (data.forceLabel) this.nodesWithForcedLabels.push(node);\n\n      if (this.settings.zIndex) {\n        if (data.zIndex < nodeZExtent[0]) nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > nodeZExtent[1]) nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    for (var type in this.nodePrograms) {\n      if (!this.nodePrograms.hasOwnProperty(type)) {\n        throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n      }\n\n      if (!keepArrays) this.nodePrograms[type].allocate(nodesPerPrograms[type] || 0); // We reset that count here, so that we can reuse it while calling the Program#process methods:\n\n      nodesPerPrograms[type] = 0;\n    } // Handling node z-index\n    // TODO: z-index needs us to compute display data before hand\n\n\n    if (this.settings.zIndex && nodeZExtent[0] !== nodeZExtent[1]) nodes = (0, utils_1.zIndexOrdering)(nodeZExtent, function (node) {\n      return _this.nodeDataCache[node].zIndex;\n    }, nodes);\n\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n      var data = this.nodeDataCache[node];\n      this.quadtree.add(node, data.x, 1 - data.y, data.size / this.width);\n      if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n        matrix: nullCameraMatrix\n      }));\n      this.nodePrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++); // Save the node in the highlighted set if needed\n\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(node);\n      this.nodeKeyToIndex[node] = i;\n    }\n\n    this.labelGrid.organize();\n    var edgesPerPrograms = {};\n    var edges = graph.edges();\n\n    for (var i = 0, l = edges.length; i < l; i++) {\n      var edge = edges[i]; // Edge display data resolution:\n      //   1. First we get the edge's attributes\n      //   2. We optionally reduce them using the function provided by the user\n      //      Note that this function must return a total object and won't be merged\n      //   3. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n\n      var attr = Object.assign({}, graph.getEdgeAttributes(edge));\n      if (settings.edgeReducer) attr = settings.edgeReducer(edge, attr);\n      var data = applyEdgeDefaults(this.settings, edge, attr);\n      edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n      this.edgeDataCache[edge] = data;\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.push(edge);\n\n      if (this.settings.zIndex) {\n        if (data.zIndex < edgeZExtent[0]) edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > edgeZExtent[1]) edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    for (var type in this.edgePrograms) {\n      if (!this.edgePrograms.hasOwnProperty(type)) {\n        throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(type, \"\\\"!\"));\n      }\n\n      if (!keepArrays) this.edgePrograms[type].allocate(edgesPerPrograms[type] || 0); // We reset that count here, so that we can reuse it while calling the Program#process methods:\n\n      edgesPerPrograms[type] = 0;\n    } // Handling edge z-index\n\n\n    if (this.settings.zIndex && edgeZExtent[0] !== edgeZExtent[1]) edges = (0, utils_1.zIndexOrdering)(edgeZExtent, function (edge) {\n      return _this.edgeDataCache[edge].zIndex;\n    }, edges);\n\n    for (var i = 0, l = edges.length; i < l; i++) {\n      var edge = edges[i];\n      var data = this.edgeDataCache[edge];\n      var extremities = graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]];\n      var hidden = data.hidden || sourceData.hidden || targetData.hidden;\n      this.edgePrograms[data.type].process(sourceData, targetData, data, hidden, edgesPerPrograms[data.type]++);\n      this.nodeKeyToIndex[edge] = i;\n    }\n\n    for (var type in this.edgePrograms) {\n      var program = this.edgePrograms[type];\n      if (!keepArrays && typeof program.computeIndices === \"function\") program.computeIndices();\n    }\n\n    return this;\n  };\n  /**\n   * Method that backports potential settings updates where it's needed.\n   * @private\n   */\n\n\n  Sigma.prototype.handleSettingsUpdate = function () {\n    this.camera.minRatio = this.settings.minCameraRatio;\n    this.camera.maxRatio = this.settings.maxCameraRatio;\n    this.camera.setState(this.camera.validateState(this.camera.getState()));\n    return this;\n  };\n  /**\n   * Method that decides whether to reprocess graph or not, and then render the\n   * graph.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype._refresh = function () {\n    // Do we need to process data?\n    if (this.needToProcess) {\n      this.process();\n    } else if (this.needToSoftProcess) {\n      this.process(true);\n    } // Resetting state\n\n\n    this.needToProcess = false;\n    this.needToSoftProcess = false; // Rendering\n\n    this.render();\n    return this;\n  };\n  /**\n   * Method that schedules a `_refresh` call if none has been scheduled yet. It\n   * will then be processed next available frame.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype._scheduleRefresh = function () {\n    var _this = this;\n\n    if (!this.renderFrame) {\n      this.renderFrame = (0, utils_1.requestFrame)(function () {\n        _this._refresh();\n\n        _this.renderFrame = null;\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Method used to render labels.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.renderLabels = function () {\n    if (!this.settings.renderLabels) return this;\n    var cameraState = this.camera.getState(); // Finding visible nodes to display their labels\n\n    var visibleNodes;\n\n    if (cameraState.ratio >= 1) {\n      // Camera is unzoomed so no need to ask the quadtree for visible nodes\n      visibleNodes = new Set(this.graph.nodes());\n    } else {\n      // Let's ask the quadtree\n      var viewRectangle = this.viewRectangle();\n      visibleNodes = new Set(this.quadtree.rectangle(viewRectangle.x1, 1 - viewRectangle.y1, viewRectangle.x2, 1 - viewRectangle.y2, viewRectangle.height));\n    } // Selecting labels to draw\n    // TODO: drop gridsettings likewise\n    // TODO: optimize through visible nodes\n\n\n    var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity).concat(this.nodesWithForcedLabels);\n    this.displayedLabels = new Set(); // Drawing labels\n\n    var context = this.canvasContexts.labels;\n\n    for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n      var node = labelsToDisplay[i];\n      var data = this.nodeDataCache[node]; // If the node was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n\n      if (this.displayedLabels.has(node)) continue; // If the node is hidden, we don't need to display its label obviously\n\n      if (data.hidden) continue;\n\n      var _a = this.framedGraphToViewport(data),\n          x = _a.x,\n          y = _a.y; // TODO: we can cache the labels we need to render until the camera's ratio changes\n      // TODO: this should be computed in the canvas components?\n\n\n      var size = this.scaleSize(data.size);\n      if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n      if (!visibleNodes.has(node)) continue; // TODO:\n      // Because displayed edge labels depend directly on actually rendered node\n      // labels, we need to only add to this.displayedLabels nodes whose label\n      // is rendered.\n      // This makes this.displayedLabels depend on viewport, which might become\n      // an issue once we start memoizing getLabelsToDisplay.\n\n      this.displayedLabels.add(node);\n      this.settings.labelRenderer(context, __assign(__assign({\n        key: node\n      }, data), {\n        size: size,\n        x: x,\n        y: y\n      }), this.settings);\n    }\n\n    return this;\n  };\n  /**\n   * Method used to render edge labels, based on which node labels were\n   * rendered.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.renderEdgeLabels = function () {\n    if (!this.settings.renderEdgeLabels) return this;\n    var context = this.canvasContexts.edgeLabels; // Clearing\n\n    context.clearRect(0, 0, this.width, this.height);\n    var edgeLabelsToDisplay = (0, labels_1.edgeLabelsToDisplayFromNodes)({\n      graph: this.graph,\n      hoveredNode: this.hoveredNode,\n      displayedNodeLabels: this.displayedLabels,\n      highlightedNodes: this.highlightedNodes\n    }).concat(this.edgesWithForcedLabels);\n    var displayedLabels = new Set();\n\n    for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n      var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge]; // If the edge was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n\n      if (displayedLabels.has(edge)) continue; // If the edge is hidden we don't need to display its label\n      // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n\n      if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n        continue;\n      }\n\n      this.settings.edgeLabelRenderer(context, __assign(__assign({\n        key: edge\n      }, edgeData), {\n        size: this.scaleSize(edgeData.size)\n      }), __assign(__assign(__assign({\n        key: extremities[0]\n      }, sourceData), this.framedGraphToViewport(sourceData)), {\n        size: this.scaleSize(sourceData.size)\n      }), __assign(__assign(__assign({\n        key: extremities[1]\n      }, targetData), this.framedGraphToViewport(targetData)), {\n        size: this.scaleSize(targetData.size)\n      }), this.settings);\n      displayedLabels.add(edge);\n    }\n\n    return this;\n  };\n  /**\n   * Method used to render the highlighted nodes.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.renderHighlightedNodes = function () {\n    var _this = this;\n\n    var context = this.canvasContexts.hovers; // Clearing\n\n    context.clearRect(0, 0, this.width, this.height); // Rendering\n\n    var render = function (node) {\n      var data = _this.nodeDataCache[node];\n\n      var _a = _this.framedGraphToViewport(data),\n          x = _a.x,\n          y = _a.y;\n\n      var size = _this.scaleSize(data.size);\n\n      _this.settings.hoverRenderer(context, __assign(__assign({\n        key: node\n      }, data), {\n        size: size,\n        x: x,\n        y: y\n      }), _this.settings);\n    };\n\n    var nodesToRender = [];\n\n    if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n      nodesToRender.push(this.hoveredNode);\n    }\n\n    this.highlightedNodes.forEach(function (node) {\n      // The hovered node has already been highlighted\n      if (node !== _this.hoveredNode) nodesToRender.push(node);\n    }); // Draw labels:\n\n    nodesToRender.forEach(function (node) {\n      return render(node);\n    }); // Draw WebGL nodes on top of the labels:\n\n    var nodesPerPrograms = {}; // 1. Count nodes per type:\n\n    nodesToRender.forEach(function (node) {\n      var type = _this.nodeDataCache[node].type;\n      nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n    }); // 2. Allocate for each type for the proper number of nodes\n\n    for (var type in this.hoverNodePrograms) {\n      this.hoverNodePrograms[type].allocate(nodesPerPrograms[type] || 0); // Also reset count, to use when rendering:\n\n      nodesPerPrograms[type] = 0;\n    } // 3. Process all nodes to render:\n\n\n    nodesToRender.forEach(function (node) {\n      var data = _this.nodeDataCache[node];\n\n      _this.hoverNodePrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);\n    }); // 4. Render:\n\n    for (var type in this.hoverNodePrograms) {\n      var program = this.hoverNodePrograms[type];\n      program.bind();\n      program.bufferData();\n      program.render({\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        ratio: this.camera.ratio,\n        correctionRatio: this.correctionRatio / this.camera.ratio,\n        scalingRatio: PIXEL_RATIO\n      });\n    }\n  };\n  /**\n   * Method used to schedule a hover render.\n   *\n   */\n\n\n  Sigma.prototype.scheduleHighlightedNodesRender = function () {\n    var _this = this;\n\n    if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n    this.renderHighlightedNodesFrame = (0, utils_1.requestFrame)(function () {\n      // Resetting state\n      _this.renderHighlightedNodesFrame = null; // Rendering\n\n      _this.renderHighlightedNodes();\n\n      _this.renderEdgeLabels();\n    });\n  };\n  /**\n   * Method used to render.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.render = function () {\n    // If a render was scheduled, we cancel it\n    if (this.renderFrame) {\n      (0, utils_1.cancelFrame)(this.renderFrame);\n      this.renderFrame = null;\n      this.needToProcess = false;\n      this.needToSoftProcess = false;\n    } // First we need to resize\n\n\n    this.resize(); // Clearing the canvases\n\n    this.clear(); // Recomputing useful camera-related values:\n\n    this.updateCachedValues(); // If we have no nodes we can stop right there\n\n    if (!this.graph.order) return this; // TODO: improve this heuristic or move to the captor itself?\n    // TODO: deal with the touch captor here as well\n\n    var mouseCaptor = this.mouseCaptor;\n    var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection; // Then we need to extract a matrix from the camera\n\n    var cameraState = this.camera.getState();\n    var viewportDimensions = this.getDimensions();\n    var graphDimensions = this.getGraphDimensions();\n    var padding = this.getSetting(\"stagePadding\") || 0;\n    this.matrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding);\n    this.invMatrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding, true);\n    this.correctionRatio = (0, utils_1.getMatrixImpact)(this.matrix, cameraState, viewportDimensions); // Drawing nodes\n\n    for (var type in this.nodePrograms) {\n      var program = this.nodePrograms[type];\n      program.bind();\n      program.bufferData();\n      program.render({\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        ratio: cameraState.ratio,\n        correctionRatio: this.correctionRatio / cameraState.ratio,\n        scalingRatio: PIXEL_RATIO\n      });\n    } // Drawing edges\n\n\n    if (!this.settings.hideEdgesOnMove || !moving) {\n      for (var type in this.edgePrograms) {\n        var program = this.edgePrograms[type];\n        program.bind();\n        program.bufferData();\n        program.render({\n          matrix: this.matrix,\n          width: this.width,\n          height: this.height,\n          ratio: cameraState.ratio,\n          correctionRatio: this.correctionRatio / cameraState.ratio,\n          scalingRatio: PIXEL_RATIO\n        });\n      }\n    } // Do not display labels on move per setting\n\n\n    if (this.settings.hideLabelsOnMove && moving) return this;\n    this.renderLabels();\n    this.renderEdgeLabels();\n    this.renderHighlightedNodes();\n    this.emit(\"afterRender\");\n    return this;\n  };\n  /**\n   * Internal method used to update expensive and therefore cached values\n   * each time the camera state is updated.\n   */\n\n\n  Sigma.prototype.updateCachedValues = function () {\n    var ratio = this.camera.getState().ratio;\n    this.cameraSizeRatio = Math.sqrt(ratio);\n  };\n  /**---------------------------------------------------------------------------\n   * Public API.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the renderer's camera.\n   *\n   * @return {Camera}\n   */\n\n\n  Sigma.prototype.getCamera = function () {\n    return this.camera;\n  };\n  /**\n   * Method returning the renderer's graph.\n   *\n   * @return {Graph}\n   */\n\n\n  Sigma.prototype.getGraph = function () {\n    return this.graph;\n  };\n  /**\n   * Method returning the mouse captor.\n   *\n   * @return {MouseCaptor}\n   */\n\n\n  Sigma.prototype.getMouseCaptor = function () {\n    return this.mouseCaptor;\n  };\n  /**\n   * Method returning the touch captor.\n   *\n   * @return {TouchCaptor}\n   */\n\n\n  Sigma.prototype.getTouchCaptor = function () {\n    return this.touchCaptor;\n  };\n  /**\n   * Method returning the current renderer's dimensions.\n   *\n   * @return {Dimensions}\n   */\n\n\n  Sigma.prototype.getDimensions = function () {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  };\n  /**\n   * Method returning the current graph's dimensions.\n   *\n   * @return {Dimensions}\n   */\n\n\n  Sigma.prototype.getGraphDimensions = function () {\n    var extent = this.customBBox || this.nodeExtent;\n    return {\n      width: extent.x[1] - extent.x[0] || 1,\n      height: extent.y[1] - extent.y[0] || 1\n    };\n  };\n  /**\n   * Method used to get all the sigma node attributes.\n   * It's usefull for example to get the position of a node\n   * and to get values that are set by the nodeReducer\n   *\n   * @param  {string} key - The node's key.\n   * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n   */\n\n\n  Sigma.prototype.getNodeDisplayData = function (key) {\n    var node = this.nodeDataCache[key];\n    return node ? Object.assign({}, node) : undefined;\n  };\n  /**\n   * Method used to get all the sigma edge attributes.\n   * It's usefull for example to get values that are set by the edgeReducer.\n   *\n   * @param  {string} key - The edge's key.\n   * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n   */\n\n\n  Sigma.prototype.getEdgeDisplayData = function (key) {\n    var edge = this.edgeDataCache[key];\n    return edge ? Object.assign({}, edge) : undefined;\n  };\n  /**\n   * Method returning a copy of the settings collection.\n   *\n   * @return {Settings} A copy of the settings collection.\n   */\n\n\n  Sigma.prototype.getSettings = function () {\n    return __assign({}, this.settings);\n  };\n  /**\n   * Method returning the current value for a given setting key.\n   *\n   * @param  {string} key - The setting key to get.\n   * @return {any} The value attached to this setting key or undefined if not found\n   */\n\n\n  Sigma.prototype.getSetting = function (key) {\n    return this.settings[key];\n  };\n  /**\n   * Method setting the value of a given setting key. Note that this will schedule\n   * a new render next frame.\n   *\n   * @param  {string} key - The setting key to set.\n   * @param  {any}    value - The value to set.\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.setSetting = function (key, value) {\n    this.settings[key] = value;\n    (0, settings_1.validateSettings)(this.settings);\n    this.handleSettingsUpdate();\n    this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n\n    this._scheduleRefresh();\n\n    return this;\n  };\n  /**\n   * Method updating the value of a given setting key using the provided function.\n   * Note that this will schedule a new render next frame.\n   *\n   * @param  {string}   key     - The setting key to set.\n   * @param  {function} updater - The update function.\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.updateSetting = function (key, updater) {\n    this.settings[key] = updater(this.settings[key]);\n    (0, settings_1.validateSettings)(this.settings);\n    this.handleSettingsUpdate();\n    this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n\n    this._scheduleRefresh();\n\n    return this;\n  };\n  /**\n   * Method used to resize the renderer.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.resize = function () {\n    var previousWidth = this.width,\n        previousHeight = this.height;\n    this.width = this.container.offsetWidth;\n    this.height = this.container.offsetHeight;\n    if (this.width === 0) throw new Error(\"Sigma: container has no width.\");\n    if (this.height === 0) throw new Error(\"Sigma: container has no height.\"); // If nothing has changed, we can stop right here\n\n    if (previousWidth === this.width && previousHeight === this.height) return this; // Sizing dom elements\n\n    for (var id in this.elements) {\n      var element = this.elements[id];\n      element.style.width = this.width + \"px\";\n      element.style.height = this.height + \"px\";\n    } // Sizing canvas contexts\n\n\n    for (var id in this.canvasContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * PIXEL_RATIO + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * PIXEL_RATIO + \"px\");\n      if (PIXEL_RATIO !== 1) this.canvasContexts[id].scale(PIXEL_RATIO, PIXEL_RATIO);\n    } // Sizing WebGL contexts\n\n\n    for (var id in this.webGLContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * PIXEL_RATIO + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * PIXEL_RATIO + \"px\");\n      this.webGLContexts[id].viewport(0, 0, this.width * PIXEL_RATIO, this.height * PIXEL_RATIO);\n    }\n\n    return this;\n  };\n  /**\n   * Method used to clear all the canvases.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.clear = function () {\n    this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);\n    this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT);\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);\n    this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n    return this;\n  };\n  /**\n   * Method used to refresh all computed data.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.refresh = function () {\n    this.needToProcess = true;\n\n    this._refresh();\n\n    return this;\n  };\n  /**\n   * Method used to refresh all computed data, at the next available frame.\n   * If this method has already been called this frame, then it will only render once at the next available frame.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.scheduleRefresh = function () {\n    this.needToProcess = true;\n\n    this._scheduleRefresh();\n\n    return this;\n  };\n  /**\n   * Method used to (un)zoom, while preserving the position of a viewport point.\n   * Used for instance to zoom \"on the mouse cursor\".\n   *\n   * @param viewportTarget\n   * @param newRatio\n   * @return {CameraState}\n   */\n\n\n  Sigma.prototype.getViewportZoomedState = function (viewportTarget, newRatio) {\n    var _a = this.camera.getState(),\n        ratio = _a.ratio,\n        angle = _a.angle,\n        x = _a.x,\n        y = _a.y; // TODO: handle max zoom\n\n\n    var ratioDiff = newRatio / ratio;\n    var center = {\n      x: this.width / 2,\n      y: this.height / 2\n    };\n    var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n    var graphCenterPosition = this.viewportToFramedGraph(center);\n    return {\n      angle: angle,\n      x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n      y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n      ratio: newRatio\n    };\n  };\n  /**\n   * Method returning the abstract rectangle containing the graph according\n   * to the camera's state.\n   *\n   * @return {object} - The view's rectangle.\n   */\n\n\n  Sigma.prototype.viewRectangle = function () {\n    // TODO: reduce relative margin?\n    var marginX = 0 * this.width / 8,\n        marginY = 0 * this.height / 8;\n    var p1 = this.viewportToFramedGraph({\n      x: 0 - marginX,\n      y: 0 - marginY\n    }),\n        p2 = this.viewportToFramedGraph({\n      x: this.width + marginX,\n      y: 0 - marginY\n    }),\n        h = this.viewportToFramedGraph({\n      x: 0,\n      y: this.height + marginY\n    });\n    return {\n      x1: p1.x,\n      y1: p1.y,\n      x2: p2.x,\n      y2: p2.y,\n      height: p2.y - h.y\n    };\n  };\n  /**\n   * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n\n\n  Sigma.prototype.framedGraphToViewport = function (coordinates, override) {\n    if (override === void 0) {\n      override = {};\n    }\n\n    var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n    var matrix = override.matrix ? override.matrix : recomputeMatrix ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0) : this.matrix;\n    var framedGraphVec = [coordinates.x, coordinates.y, 1];\n    var viewportVec = (0, matrices_1.multiplyVec)(matrix, framedGraphVec);\n    return {\n      x: (1 + viewportVec[0]) * this.width / 2,\n      y: (1 - viewportVec[1]) * this.height / 2\n    };\n  };\n  /**\n   * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n\n\n  Sigma.prototype.viewportToFramedGraph = function (coordinates, override) {\n    if (override === void 0) {\n      override = {};\n    }\n\n    var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n    var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true) : this.invMatrix;\n    var viewportVec = [coordinates.x / this.width * 2 - 1, 1 - coordinates.y / this.height * 2, 1];\n    var framedGraphVec = (0, matrices_1.multiplyVec)(invMatrix, viewportVec);\n    return {\n      x: framedGraphVec[0],\n      y: framedGraphVec[1]\n    };\n  };\n  /**\n   * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n   * stage) to the graph system (the reference system of data as they are in the given graph instance).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  viewportPoint\n   * @param {CoordinateConversionOverride} override\n   */\n\n\n  Sigma.prototype.viewportToGraph = function (viewportPoint, override) {\n    if (override === void 0) {\n      override = {};\n    }\n\n    return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n  };\n  /**\n   * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n   * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  graphPoint\n   * @param {CoordinateConversionOverride} override\n   */\n\n\n  Sigma.prototype.graphToViewport = function (graphPoint, override) {\n    if (override === void 0) {\n      override = {};\n    }\n\n    return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n  };\n  /**\n   * Method returning the graph's bounding box.\n   *\n   * @return {{ x: Extent, y: Extent }}\n   */\n\n\n  Sigma.prototype.getBBox = function () {\n    return (0, utils_1.graphExtent)(this.graph);\n  };\n  /**\n   * Method returning the graph's custom bounding box, if any.\n   *\n   * @return {{ x: Extent, y: Extent } | null}\n   */\n\n\n  Sigma.prototype.getCustomBBox = function () {\n    return this.customBBox;\n  };\n  /**\n   * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n   *\n   * @return {Sigma}\n   */\n\n\n  Sigma.prototype.setCustomBBox = function (customBBox) {\n    this.customBBox = customBBox;\n\n    this._scheduleRefresh();\n\n    return this;\n  };\n  /**\n   * Method used to shut the container & release event listeners.\n   *\n   * @return {undefined}\n   */\n\n\n  Sigma.prototype.kill = function () {\n    var graph = this.graph; // Emitting \"kill\" events so that plugins and such can cleanup\n\n    this.emit(\"kill\"); // Releasing events\n\n    this.removeAllListeners(); // Releasing camera handlers\n\n    this.camera.removeListener(\"updated\", this.activeListeners.camera); // Releasing DOM events & captors\n\n    window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n    this.mouseCaptor.kill();\n    this.touchCaptor.kill(); // Releasing graph handlers\n\n    graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n    graph.removeListener(\"nodeDropped\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n    graph.removeListener(\"edgeDropped\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgesCleared\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"cleared\", this.activeListeners.graphUpdate); // Releasing cache & state\n\n    this.quadtree = new quadtree_1.default();\n    this.nodeDataCache = {};\n    this.edgeDataCache = {};\n    this.nodesWithForcedLabels = [];\n    this.edgesWithForcedLabels = [];\n    this.highlightedNodes.clear(); // Clearing frames\n\n    if (this.renderFrame) {\n      (0, utils_1.cancelFrame)(this.renderFrame);\n      this.renderFrame = null;\n    }\n\n    if (this.renderHighlightedNodesFrame) {\n      (0, utils_1.cancelFrame)(this.renderHighlightedNodesFrame);\n      this.renderHighlightedNodesFrame = null;\n    } // Destroying canvases\n\n\n    var container = this.container;\n\n    while (container.firstChild) container.removeChild(container.firstChild);\n  };\n  /**\n   * Method used to scale the given size according to the camera's ratio, i.e.\n   * zooming state.\n   *\n   * @param  {number} size - The size to scale (node size, edge thickness etc.).\n   * @return {number}      - The scaled size.\n   */\n\n\n  Sigma.prototype.scaleSize = function (size) {\n    return size / this.cameraSizeRatio;\n  };\n  /**\n   * Method that returns the collection of all used canvases.\n   * At the moment, the instantiated canvases are the following, and in the\n   * following order in the DOM:\n   * - `edges`\n   * - `nodes`\n   * - `edgeLabels`\n   * - `labels`\n   * - `hovers`\n   * - `hoverNodes`\n   * - `mouse`\n   *\n   * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n   */\n\n\n  Sigma.prototype.getCanvases = function () {\n    return __assign({}, this.elements);\n  };\n\n  return Sigma;\n}(types_1.TypedEventEmitter);\n\nexports.default = Sigma;","map":null,"metadata":{},"sourceType":"script"}