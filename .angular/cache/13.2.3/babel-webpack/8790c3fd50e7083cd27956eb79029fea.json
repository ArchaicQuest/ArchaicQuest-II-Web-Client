{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../../../utils\");\n\nvar edge_arrowHead_vert_glsl_1 = __importDefault(require(\"../shaders/edge.arrowHead.vert.glsl.js\"));\n\nvar edge_arrowHead_frag_glsl_1 = __importDefault(require(\"../shaders/edge.arrowHead.frag.glsl.js\"));\n\nvar edge_1 = require(\"./common/edge\");\n\nvar POINTS = 3,\n    ATTRIBUTES = 9,\n    STRIDE = POINTS * ATTRIBUTES;\n\nvar EdgeArrowHeadProgram =\n/** @class */\nfunction (_super) {\n  __extends(EdgeArrowHeadProgram, _super);\n\n  function EdgeArrowHeadProgram(gl) {\n    var _this = _super.call(this, gl, edge_arrowHead_vert_glsl_1.default, edge_arrowHead_frag_glsl_1.default, POINTS, ATTRIBUTES) || this; // Locations\n\n\n    _this.positionLocation = gl.getAttribLocation(_this.program, \"a_position\");\n    _this.colorLocation = gl.getAttribLocation(_this.program, \"a_color\");\n    _this.normalLocation = gl.getAttribLocation(_this.program, \"a_normal\");\n    _this.radiusLocation = gl.getAttribLocation(_this.program, \"a_radius\");\n    _this.barycentricLocation = gl.getAttribLocation(_this.program, \"a_barycentric\"); // Uniform locations\n\n    var matrixLocation = gl.getUniformLocation(_this.program, \"u_matrix\");\n    if (matrixLocation === null) throw new Error(\"EdgeArrowHeadProgram: error while getting matrixLocation\");\n    _this.matrixLocation = matrixLocation;\n    var sqrtZoomRatioLocation = gl.getUniformLocation(_this.program, \"u_sqrtZoomRatio\");\n    if (sqrtZoomRatioLocation === null) throw new Error(\"EdgeArrowHeadProgram: error while getting sqrtZoomRatioLocation\");\n    _this.sqrtZoomRatioLocation = sqrtZoomRatioLocation;\n    var correctionRatioLocation = gl.getUniformLocation(_this.program, \"u_correctionRatio\");\n    if (correctionRatioLocation === null) throw new Error(\"EdgeArrowHeadProgram: error while getting correctionRatioLocation\");\n    _this.correctionRatioLocation = correctionRatioLocation;\n\n    _this.bind();\n\n    return _this;\n  }\n\n  EdgeArrowHeadProgram.prototype.bind = function () {\n    var gl = this.gl; // Bindings\n\n    gl.enableVertexAttribArray(this.positionLocation);\n    gl.enableVertexAttribArray(this.normalLocation);\n    gl.enableVertexAttribArray(this.radiusLocation);\n    gl.enableVertexAttribArray(this.colorLocation);\n    gl.enableVertexAttribArray(this.barycentricLocation);\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n    gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n    gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20); // TODO: maybe we can optimize here by packing this in a bit mask\n\n    gl.vertexAttribPointer(this.barycentricLocation, 3, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24);\n  };\n\n  EdgeArrowHeadProgram.prototype.computeIndices = function () {// nothing to do\n  };\n\n  EdgeArrowHeadProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {\n    if (hidden) {\n      for (var i_1 = offset * STRIDE, l = i_1 + STRIDE; i_1 < l; i_1++) this.array[i_1] = 0;\n\n      return;\n    }\n\n    var thickness = data.size || 1,\n        radius = targetData.size || 1,\n        x1 = sourceData.x,\n        y1 = sourceData.y,\n        x2 = targetData.x,\n        y2 = targetData.y,\n        color = (0, utils_1.floatColor)(data.color); // Computing normals\n\n    var dx = x2 - x1,\n        dy = y2 - y1;\n    var len = dx * dx + dy * dy,\n        n1 = 0,\n        n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    var i = POINTS * ATTRIBUTES * offset;\n    var array = this.array; // First point\n\n    array[i++] = x2;\n    array[i++] = y2;\n    array[i++] = -n1;\n    array[i++] = -n2;\n    array[i++] = radius;\n    array[i++] = color;\n    array[i++] = 1;\n    array[i++] = 0;\n    array[i++] = 0; // Second point\n\n    array[i++] = x2;\n    array[i++] = y2;\n    array[i++] = -n1;\n    array[i++] = -n2;\n    array[i++] = radius;\n    array[i++] = color;\n    array[i++] = 0;\n    array[i++] = 1;\n    array[i++] = 0; // Third point\n\n    array[i++] = x2;\n    array[i++] = y2;\n    array[i++] = -n1;\n    array[i++] = -n2;\n    array[i++] = radius;\n    array[i++] = color;\n    array[i++] = 0;\n    array[i++] = 0;\n    array[i] = 1;\n  };\n\n  EdgeArrowHeadProgram.prototype.render = function (params) {\n    if (this.hasNothingToRender()) return;\n    var gl = this.gl;\n    var program = this.program;\n    gl.useProgram(program); // Binding uniforms\n\n    gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n    gl.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(params.ratio));\n    gl.uniform1f(this.correctionRatioLocation, params.correctionRatio); // Drawing:\n\n    gl.drawArrays(gl.TRIANGLES, 0, this.array.length / ATTRIBUTES);\n  };\n\n  return EdgeArrowHeadProgram;\n}(edge_1.AbstractEdgeProgram);\n\nexports.default = EdgeArrowHeadProgram;","map":null,"metadata":{},"sourceType":"script"}