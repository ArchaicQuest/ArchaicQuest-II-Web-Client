{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar captor_1 = __importStar(require(\"./captor\"));\n/**\n * Constants.\n */\n\n\nvar DRAG_TIMEOUT = 100;\nvar DRAGGED_EVENTS_TOLERANCE = 3;\nvar MOUSE_INERTIA_DURATION = 200;\nvar MOUSE_INERTIA_RATIO = 3;\nvar MOUSE_ZOOM_DURATION = 250;\nvar ZOOMING_RATIO = 1.7;\nvar DOUBLE_CLICK_TIMEOUT = 300;\nvar DOUBLE_CLICK_ZOOMING_RATIO = 2.2;\nvar DOUBLE_CLICK_ZOOMING_DURATION = 200;\n/**\n * Mouse captor class.\n *\n * @constructor\n */\n\nvar MouseCaptor =\n/** @class */\nfunction (_super) {\n  __extends(MouseCaptor, _super);\n\n  function MouseCaptor(container, renderer) {\n    var _this = _super.call(this, container, renderer) || this; // State\n\n\n    _this.enabled = true;\n    _this.draggedEvents = 0;\n    _this.downStartTime = null;\n    _this.lastMouseX = null;\n    _this.lastMouseY = null;\n    _this.isMouseDown = false;\n    _this.isMoving = false;\n    _this.movingTimeout = null;\n    _this.startCameraState = null;\n    _this.clicks = 0;\n    _this.doubleClickTimeout = null;\n    _this.currentWheelDirection = 0; // Binding methods\n\n    _this.handleClick = _this.handleClick.bind(_this);\n    _this.handleRightClick = _this.handleRightClick.bind(_this);\n    _this.handleDown = _this.handleDown.bind(_this);\n    _this.handleUp = _this.handleUp.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n    _this.handleWheel = _this.handleWheel.bind(_this);\n    _this.handleOut = _this.handleOut.bind(_this); // Binding events\n\n    container.addEventListener(\"click\", _this.handleClick, false);\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, false);\n    container.addEventListener(\"mousedown\", _this.handleDown, false);\n    container.addEventListener(\"wheel\", _this.handleWheel, false);\n    container.addEventListener(\"mouseout\", _this.handleOut, false);\n    document.addEventListener(\"mousemove\", _this.handleMove, false);\n    document.addEventListener(\"mouseup\", _this.handleUp, false);\n    return _this;\n  }\n\n  MouseCaptor.prototype.kill = function () {\n    var container = this.container;\n    container.removeEventListener(\"click\", this.handleClick);\n    container.removeEventListener(\"contextmenu\", this.handleRightClick);\n    container.removeEventListener(\"mousedown\", this.handleDown);\n    container.removeEventListener(\"wheel\", this.handleWheel);\n    container.removeEventListener(\"mouseout\", this.handleOut);\n    document.removeEventListener(\"mousemove\", this.handleMove);\n    document.removeEventListener(\"mouseup\", this.handleUp);\n  };\n\n  MouseCaptor.prototype.handleClick = function (e) {\n    var _this = this;\n\n    if (!this.enabled) return;\n    this.clicks++;\n\n    if (this.clicks === 2) {\n      this.clicks = 0;\n\n      if (typeof this.doubleClickTimeout === \"number\") {\n        clearTimeout(this.doubleClickTimeout);\n        this.doubleClickTimeout = null;\n      }\n\n      return this.handleDoubleClick(e);\n    }\n\n    setTimeout(function () {\n      _this.clicks = 0;\n      _this.doubleClickTimeout = null;\n    }, DOUBLE_CLICK_TIMEOUT); // NOTE: this is here to prevent click events on drag\n\n    if (this.draggedEvents < DRAGGED_EVENTS_TOLERANCE) this.emit(\"click\", (0, captor_1.getMouseCoords)(e, this.container));\n  };\n\n  MouseCaptor.prototype.handleRightClick = function (e) {\n    if (!this.enabled) return;\n    this.emit(\"rightClick\", (0, captor_1.getMouseCoords)(e, this.container));\n  };\n\n  MouseCaptor.prototype.handleDoubleClick = function (e) {\n    if (!this.enabled) return;\n    e.preventDefault();\n    e.stopPropagation();\n    var mouseCoords = (0, captor_1.getMouseCoords)(e, this.container);\n    this.emit(\"doubleClick\", mouseCoords);\n    if (mouseCoords.sigmaDefaultPrevented) return; // default behavior\n\n    var camera = this.renderer.getCamera();\n    var newRatio = camera.getBoundedRatio(camera.getState().ratio / DOUBLE_CLICK_ZOOMING_RATIO);\n    camera.animate(this.renderer.getViewportZoomedState((0, captor_1.getPosition)(e, this.container), newRatio), {\n      easing: \"quadraticInOut\",\n      duration: DOUBLE_CLICK_ZOOMING_DURATION\n    });\n  };\n\n  MouseCaptor.prototype.handleDown = function (e) {\n    if (!this.enabled) return;\n    this.startCameraState = this.renderer.getCamera().getState();\n\n    var _a = (0, captor_1.getPosition)(e, this.container),\n        x = _a.x,\n        y = _a.y;\n\n    this.lastMouseX = x;\n    this.lastMouseY = y;\n    this.draggedEvents = 0;\n    this.downStartTime = Date.now(); // TODO: dispatch events\n    // Left button pressed\n\n    this.isMouseDown = true;\n    this.emit(\"mousedown\", (0, captor_1.getMouseCoords)(e, this.container));\n  };\n\n  MouseCaptor.prototype.handleUp = function (e) {\n    var _this = this;\n\n    if (!this.enabled || !this.isMouseDown) return;\n    var camera = this.renderer.getCamera();\n    this.isMouseDown = false;\n\n    if (typeof this.movingTimeout === \"number\") {\n      clearTimeout(this.movingTimeout);\n      this.movingTimeout = null;\n    }\n\n    var _a = (0, captor_1.getPosition)(e, this.container),\n        x = _a.x,\n        y = _a.y;\n\n    var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n      x: 0,\n      y: 0\n    };\n\n    if (this.isMoving) {\n      camera.animate({\n        x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n        y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y)\n      }, {\n        duration: MOUSE_INERTIA_DURATION,\n        easing: \"quadraticOut\"\n      });\n    } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n      camera.setState({\n        x: cameraState.x,\n        y: cameraState.y\n      });\n    }\n\n    this.isMoving = false;\n    setTimeout(function () {\n      _this.draggedEvents = 0;\n\n      _this.renderer.refresh();\n    }, 0);\n    this.emit(\"mouseup\", (0, captor_1.getMouseCoords)(e, this.container));\n  };\n\n  MouseCaptor.prototype.handleMove = function (e) {\n    var _this = this;\n\n    if (!this.enabled) return;\n    var mouseCoords = (0, captor_1.getMouseCoords)(e, this.container); // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n    // a drag-and-drop effect that works even when the mouse is out of the\n    // container:\n\n    this.emit(\"mousemovebody\", mouseCoords); // Only trigger the \"mousemove\" event when the mouse is actually hovering\n    // the container, to avoid weirdly hovering nodes and/or edges when the\n    // mouse is not hover the container:\n\n    if (e.target === this.container) {\n      this.emit(\"mousemove\", mouseCoords);\n    } // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n    // stage while the mouse is not hover the container:\n\n\n    if (this.isMouseDown) {\n      this.isMoving = true;\n      this.draggedEvents++;\n\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n      }\n\n      this.movingTimeout = window.setTimeout(function () {\n        _this.movingTimeout = null;\n        _this.isMoving = false;\n      }, DRAG_TIMEOUT);\n      var camera = this.renderer.getCamera();\n\n      var _a = (0, captor_1.getPosition)(e, this.container),\n          eX = _a.x,\n          eY = _a.y;\n\n      var lastMouse = this.renderer.viewportToFramedGraph({\n        x: this.lastMouseX,\n        y: this.lastMouseY\n      });\n      var mouse = this.renderer.viewportToFramedGraph({\n        x: eX,\n        y: eY\n      });\n      var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n      var cameraState = camera.getState();\n      var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n      camera.setState({\n        x: x,\n        y: y\n      });\n      this.lastMouseX = eX;\n      this.lastMouseY = eY;\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  };\n\n  MouseCaptor.prototype.handleWheel = function (e) {\n    var _this = this;\n\n    if (!this.enabled) return;\n    e.preventDefault();\n    e.stopPropagation();\n    var delta = (0, captor_1.getWheelDelta)(e);\n    if (!delta) return;\n    var wheelCoords = (0, captor_1.getWheelCoords)(e, this.container);\n    this.emit(\"wheel\", wheelCoords);\n    if (wheelCoords.sigmaDefaultPrevented) return; // Default behavior\n\n    var ratioDiff = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;\n    var camera = this.renderer.getCamera();\n    var newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n    var wheelDirection = delta > 0 ? 1 : -1;\n    var now = Date.now(); // Cancel events that are too close too each other and in the same direction:\n\n    if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < MOUSE_ZOOM_DURATION / 5) {\n      return;\n    }\n\n    camera.animate(this.renderer.getViewportZoomedState((0, captor_1.getPosition)(e, this.container), newRatio), {\n      easing: \"quadraticOut\",\n      duration: MOUSE_ZOOM_DURATION\n    }, function () {\n      _this.currentWheelDirection = 0;\n    });\n    this.currentWheelDirection = wheelDirection;\n    this.lastWheelTriggerTime = now;\n  };\n\n  MouseCaptor.prototype.handleOut = function () {// TODO: dispatch event\n  };\n\n  return MouseCaptor;\n}(captor_1.default);\n\nexports.default = MouseCaptor;","map":null,"metadata":{},"sourceType":"script"}