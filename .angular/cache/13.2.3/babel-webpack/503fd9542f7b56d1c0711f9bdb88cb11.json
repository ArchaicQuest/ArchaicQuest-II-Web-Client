{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateGraph = exports.canUse32BitsIndices = exports.extractPixel = exports.getMatrixImpact = exports.matrixFromCamera = exports.getCorrectionRatio = exports.floatColor = exports.zIndexOrdering = exports.createNormalizationFunction = exports.graphExtent = exports.getPixelRatio = exports.createElement = exports.cancelFrame = exports.requestFrame = exports.assignDeep = exports.assign = exports.isPlainObject = void 0;\n\nvar is_graph_1 = __importDefault(require(\"graphology-utils/is-graph\"));\n\nvar matrices_1 = require(\"./matrices\");\n\nvar data_1 = require(\"./data\");\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\n\nfunction isPlainObject(value) {\n  return typeof value === \"object\" && value !== null && value.constructor === Object;\n}\n\nexports.isPlainObject = isPlainObject;\n/**\n * Helper to use Object.assign with more than two objects.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\n\nfunction assign(target) {\n  var objects = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    objects[_i - 1] = arguments[_i];\n  }\n\n  target = target || {};\n\n  for (var i = 0, l = objects.length; i < l; i++) {\n    var o = objects[i];\n    if (!o) continue;\n    Object.assign(target, o);\n  }\n\n  return target;\n}\n\nexports.assign = assign;\n/**\n * Very simple recursive Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\n\nfunction assignDeep(target) {\n  var objects = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    objects[_i - 1] = arguments[_i];\n  }\n\n  target = target || {};\n\n  for (var i = 0, l = objects.length; i < l; i++) {\n    var o = objects[i];\n    if (!o) continue;\n\n    for (var k in o) {\n      if (isPlainObject(o[k])) {\n        target[k] = assignDeep(target[k], o[k]);\n      } else {\n        target[k] = o[k];\n      }\n    }\n  }\n\n  return target;\n}\n\nexports.assignDeep = assignDeep;\n/**\n * Just some dirty trick to make requestAnimationFrame and cancelAnimationFrame \"work\" in Node.js, for unit tests:\n */\n\nexports.requestFrame = typeof requestAnimationFrame !== \"undefined\" ? function (callback) {\n  return requestAnimationFrame(callback);\n} : function (callback) {\n  return setTimeout(callback, 0);\n};\nexports.cancelFrame = typeof cancelAnimationFrame !== \"undefined\" ? function (requestID) {\n  return cancelAnimationFrame(requestID);\n} : function (requestID) {\n  return clearTimeout(requestID);\n};\n/**\n * Function used to create DOM elements easily.\n *\n * @param  {string} tag        - Tag name of the element to create.\n * @param  {object} style      - Styles map.\n * @param  {object} attributes - Attributes map.\n * @return {HTMLElement}\n */\n\nfunction createElement(tag, style, attributes) {\n  var element = document.createElement(tag);\n\n  if (style) {\n    for (var k in style) {\n      element.style[k] = style[k];\n    }\n  }\n\n  if (attributes) {\n    for (var k in attributes) {\n      element.setAttribute(k, attributes[k]);\n    }\n  }\n\n  return element;\n}\n\nexports.createElement = createElement;\n/**\n * Function returning the browser's pixel ratio.\n *\n * @return {number}\n */\n\nfunction getPixelRatio() {\n  if (typeof window.devicePixelRatio !== \"undefined\") return window.devicePixelRatio;\n  return 1;\n}\n\nexports.getPixelRatio = getPixelRatio;\n/**\n * Function returning the graph's node extent in x & y.\n *\n * @param  {Graph}\n * @return {object}\n */\n\nfunction graphExtent(graph) {\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  graph.forEachNode(function (_, attr) {\n    var x = attr.x,\n        y = attr.y;\n    if (x < xMin) xMin = x;\n    if (x > xMax) xMax = x;\n    if (y < yMin) yMin = y;\n    if (y > yMax) yMax = y;\n  });\n  return {\n    x: [xMin, xMax],\n    y: [yMin, yMax]\n  };\n}\n\nexports.graphExtent = graphExtent;\n\nfunction createNormalizationFunction(extent) {\n  var _a = __read(extent.x, 2),\n      minX = _a[0],\n      maxX = _a[1],\n      _b = __read(extent.y, 2),\n      minY = _b[0],\n      maxY = _b[1];\n\n  var ratio = Math.max(maxX - minX, maxY - minY);\n  if (ratio === 0) ratio = 1;\n  var dX = (maxX + minX) / 2,\n      dY = (maxY + minY) / 2;\n\n  var fn = function (data) {\n    return {\n      x: 0.5 + (data.x - dX) / ratio,\n      y: 0.5 + (data.y - dY) / ratio\n    };\n  }; // TODO: possibility to apply this in batch over array of indices\n\n\n  fn.applyTo = function (data) {\n    data.x = 0.5 + (data.x - dX) / ratio;\n    data.y = 0.5 + (data.y - dY) / ratio;\n  };\n\n  fn.inverse = function (data) {\n    return {\n      x: dX + ratio * (data.x - 0.5),\n      y: dY + ratio * (data.y - 0.5)\n    };\n  };\n\n  fn.ratio = ratio;\n  return fn;\n}\n\nexports.createNormalizationFunction = createNormalizationFunction;\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n *\n * @param  {number}   extent   - [min, max] z values.\n * @param  {function} getter   - Z attribute getter function.\n * @param  {array}    elements - The array to sort.\n * @return {array} - The sorted array.\n */\n\nfunction zIndexOrdering(extent, getter, elements) {\n  // If k is > n, we'll use a standard sort\n  return elements.sort(function (a, b) {\n    var zA = getter(a) || 0,\n        zB = getter(b) || 0;\n    if (zA < zB) return -1;\n    if (zA > zB) return 1;\n    return 0;\n  }); // TODO: counting sort optimization\n}\n\nexports.zIndexOrdering = zIndexOrdering;\n/**\n * WebGL utils\n * ===========\n */\n\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\n\nvar INT8 = new Int8Array(4);\nvar INT32 = new Int32Array(INT8.buffer, 0, 1);\nvar FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\nvar RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nvar RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\nvar FLOAT_COLOR_CACHE = {};\n\nfor (var htmlColor in data_1.HTML_COLORS) {\n  FLOAT_COLOR_CACHE[htmlColor] = floatColor(data_1.HTML_COLORS[htmlColor]);\n}\n\nfunction floatColor(val) {\n  // If the color is already computed, we yield it\n  if (typeof FLOAT_COLOR_CACHE[val] !== \"undefined\") return FLOAT_COLOR_CACHE[val];\n  var r = 0,\n      g = 0,\n      b = 0,\n      a = 1; // Handling hexadecimal notation\n\n  if (val[0] === \"#\") {\n    if (val.length === 4) {\n      r = parseInt(val.charAt(1) + val.charAt(1), 16);\n      g = parseInt(val.charAt(2) + val.charAt(2), 16);\n      b = parseInt(val.charAt(3) + val.charAt(3), 16);\n    } else {\n      r = parseInt(val.charAt(1) + val.charAt(2), 16);\n      g = parseInt(val.charAt(3) + val.charAt(4), 16);\n      b = parseInt(val.charAt(5) + val.charAt(6), 16);\n    }\n  } // Handling rgb notation\n  else if (RGBA_TEST_REGEX.test(val)) {\n    var match = val.match(RGBA_EXTRACT_REGEX);\n\n    if (match) {\n      r = +match[1];\n      g = +match[2];\n      b = +match[3];\n      if (match[4]) a = +match[4];\n    }\n  }\n\n  a = a * 255 | 0;\n  INT32[0] = (a << 24 | b << 16 | g << 8 | r) & 0xfeffffff;\n  var color = FLOAT32[0];\n  FLOAT_COLOR_CACHE[val] = color;\n  return color;\n}\n\nexports.floatColor = floatColor;\n/**\n * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This\n * helps dealing with quadtree in particular.\n * But at some point, we need to rescale it so that it takes the best place in the screen, ie. we always want to see two\n * nodes \"touching\" opposite sides of the graph, with the camera being at its default state.\n *\n * This function determines this ratio.\n */\n\nfunction getCorrectionRatio(viewportDimensions, graphDimensions) {\n  var viewportRatio = viewportDimensions.height / viewportDimensions.width;\n  var graphRatio = graphDimensions.height / graphDimensions.width; // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage\n  // is taller than wide), we can stop here to have indeed nodes touching opposite sides:\n\n  if (viewportRatio < 1 && graphRatio > 1 || viewportRatio > 1 && graphRatio < 1) {\n    return 1;\n  } // Else, we need to fit the graph inside the stage:\n  // 1. If the graph is \"squarer\" (ie. with a ratio closer to 1), we need to make the largest sides touch;\n  // 2. If the stage is \"squarer\", we need to make the smallest sides touch.\n\n\n  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));\n}\n\nexports.getCorrectionRatio = getCorrectionRatio;\n/**\n * Function returning a matrix from the current state of the camera.\n */\n// TODO: it's possible to optimize this drastically!\n\nfunction matrixFromCamera(state, viewportDimensions, graphDimensions, padding, inverse) {\n  var angle = state.angle,\n      ratio = state.ratio,\n      x = state.x,\n      y = state.y;\n  var width = viewportDimensions.width,\n      height = viewportDimensions.height;\n  var matrix = (0, matrices_1.identity)();\n  var smallestDimension = Math.min(width, height) - 2 * padding;\n  var correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);\n\n  if (!inverse) {\n    (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), 2 * (smallestDimension / width) * correctionRatio, 2 * (smallestDimension / height) * correctionRatio));\n    (0, matrices_1.multiply)(matrix, (0, matrices_1.rotate)((0, matrices_1.identity)(), -angle));\n    (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), 1 / ratio));\n    (0, matrices_1.multiply)(matrix, (0, matrices_1.translate)((0, matrices_1.identity)(), -x, -y));\n  } else {\n    (0, matrices_1.multiply)(matrix, (0, matrices_1.translate)((0, matrices_1.identity)(), x, y));\n    (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), ratio));\n    (0, matrices_1.multiply)(matrix, (0, matrices_1.rotate)((0, matrices_1.identity)(), angle));\n    (0, matrices_1.multiply)(matrix, (0, matrices_1.scale)((0, matrices_1.identity)(), width / smallestDimension / 2 / correctionRatio, height / smallestDimension / 2 / correctionRatio));\n  }\n\n  return matrix;\n}\n\nexports.matrixFromCamera = matrixFromCamera;\n/**\n * All these transformations we apply on the matrix to get it rescale the graph\n * as we want make it very hard to get pixel-perfect distances in WebGL. This\n * function returns a factor that properly cancels the matrix effect on lengths.\n *\n * [jacomyal]\n * To be fully honest, I can't really explain happens here... I notice that the\n * following ratio works (ie. it correctly compensates the matrix impact on all\n * camera states I could try):\n * > `R = size(V) / size(M * V) / W`\n * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works\n * as well with H and a vector that transforms into something parallel to (Oy).\n *\n * Also, note that we use `angle` and not `-angle` (that would seem logical,\n * since we want to anticipate the rotation), because of the fact that in WebGL,\n * the image is vertically swapped.\n */\n\nfunction getMatrixImpact(matrix, cameraState, viewportDimensions) {\n  var _a = __read((0, matrices_1.multiplyVec)(matrix, [Math.cos(cameraState.angle), Math.sin(cameraState.angle), 0]), 2),\n      x = _a[0],\n      y = _a[1];\n\n  return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;\n}\n\nexports.getMatrixImpact = getMatrixImpact;\n/**\n * Function extracting the color at the given pixel.\n */\n\nfunction extractPixel(gl, x, y, array) {\n  var data = array || new Uint8Array(4);\n  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n  return data;\n}\n\nexports.extractPixel = extractPixel;\n/**\n * Function used to know whether given webgl context can use 32 bits indices.\n */\n\nfunction canUse32BitsIndices(gl) {\n  var webgl2 = typeof WebGL2RenderingContext !== \"undefined\" && gl instanceof WebGL2RenderingContext;\n  return webgl2 || !!gl.getExtension(\"OES_element_index_uint\");\n}\n\nexports.canUse32BitsIndices = canUse32BitsIndices;\n/**\n * Check if the graph variable is a valid graph, and if sigma can render it.\n */\n\nfunction validateGraph(graph) {\n  // check if it's a valid graphology instance\n  if (!(0, is_graph_1.default)(graph)) throw new Error(\"Sigma: invalid graph instance.\"); // check if nodes have x/y attributes\n\n  graph.forEachNode(function (key, attributes) {\n    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {\n      throw new Error(\"Sigma: Coordinates of node \".concat(key, \" are invalid. A node must have a numeric 'x' and 'y' attribute.\"));\n    }\n  });\n}\n\nexports.validateGraph = validateGraph;","map":null,"metadata":{},"sourceType":"script"}