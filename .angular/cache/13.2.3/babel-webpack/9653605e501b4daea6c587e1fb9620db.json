{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.edgeLabelsToDisplayFromNodes = exports.LabelGrid = void 0;\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\n\nvar LabelCandidate =\n/** @class */\nfunction () {\n  function LabelCandidate(key, size) {\n    this.key = key;\n    this.size = size;\n  }\n\n  LabelCandidate.compare = function (first, second) {\n    // First we compare by size\n    if (first.size > second.size) return -1;\n    if (first.size < second.size) return 1; // Then since no two nodes can have the same key, we use it to\n    // deterministically tie-break by key\n\n    if (first.key > second.key) return 1; // NOTE: this comparator cannot return 0\n\n    return -1;\n  };\n\n  return LabelCandidate;\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\n\n\nvar LabelGrid =\n/** @class */\nfunction () {\n  function LabelGrid() {\n    this.width = 0;\n    this.height = 0;\n    this.cellSize = 0;\n    this.columns = 0;\n    this.rows = 0;\n    this.cells = {};\n  }\n\n  LabelGrid.prototype.resizeAndClear = function (dimensions, cellSize) {\n    this.width = dimensions.width;\n    this.height = dimensions.height;\n    this.cellSize = cellSize;\n    this.columns = Math.ceil(dimensions.width / cellSize);\n    this.rows = Math.ceil(dimensions.height / cellSize);\n    this.cells = {};\n  };\n\n  LabelGrid.prototype.getIndex = function (pos) {\n    var xIndex = Math.floor(pos.x / this.cellSize);\n    var yIndex = Math.floor(pos.y / this.cellSize);\n    return yIndex * this.columns + xIndex;\n  };\n\n  LabelGrid.prototype.add = function (key, size, pos) {\n    var candidate = new LabelCandidate(key, size);\n    var index = this.getIndex(pos);\n    var cell = this.cells[index];\n\n    if (!cell) {\n      cell = [];\n      this.cells[index] = cell;\n    }\n\n    cell.push(candidate);\n  };\n\n  LabelGrid.prototype.organize = function () {\n    for (var k in this.cells) {\n      var cell = this.cells[k];\n      cell.sort(LabelCandidate.compare);\n    }\n  };\n\n  LabelGrid.prototype.getLabelsToDisplay = function (ratio, density) {\n    // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n    // TODO: adjust threshold lower, but increase cells a bit?\n    // TODO: hunt for geom issue in disguise\n    // TODO: memoize while ratio does not move. method to force recompute\n    var cellArea = this.cellSize * this.cellSize;\n    var scaledCellArea = cellArea / ratio / ratio;\n    var scaledDensity = scaledCellArea * density / cellArea;\n    var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n    var labels = [];\n\n    for (var k in this.cells) {\n      var cell = this.cells[k];\n\n      for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n        labels.push(cell[i].key);\n      }\n    }\n\n    return labels;\n  };\n\n  return LabelGrid;\n}();\n\nexports.LabelGrid = LabelGrid;\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\n\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n      hoveredNode = params.hoveredNode,\n      highlightedNodes = params.highlightedNodes,\n      displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = []; // TODO: the code below can be optimized using #.forEach and batching the code per adj\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\nexports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;","map":null,"metadata":{},"sourceType":"script"}