{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Sigma.js WebGL Renderer Edge Program\n * =====================================\n *\n * Program rendering edges as thick lines using four points translated\n * orthogonally from the source & target's centers by half thickness.\n *\n * Rendering two triangles by using only four points is made possible through\n * the use of indices.\n *\n * This method should be faster than the 6 points / 2 triangles approach and\n * should handle thickness better than with gl.LINES.\n *\n * This version of the shader balances geometry computation evenly between\n * the CPU & GPU (normals are computed on the CPU side).\n * @module\n */\n\nvar utils_1 = require(\"../../../utils\");\n\nvar edge_vert_glsl_1 = __importDefault(require(\"../shaders/edge.vert.glsl.js\"));\n\nvar edge_frag_glsl_1 = __importDefault(require(\"../shaders/edge.frag.glsl.js\"));\n\nvar edge_1 = require(\"./common/edge\");\n\nvar POINTS = 4,\n    ATTRIBUTES = 5,\n    STRIDE = POINTS * ATTRIBUTES;\n\nvar EdgeProgram =\n/** @class */\nfunction (_super) {\n  __extends(EdgeProgram, _super);\n\n  function EdgeProgram(gl) {\n    var _this = _super.call(this, gl, edge_vert_glsl_1.default, edge_frag_glsl_1.default, POINTS, ATTRIBUTES) || this; // Initializing indices buffer\n\n\n    var indicesBuffer = gl.createBuffer();\n    if (indicesBuffer === null) throw new Error(\"EdgeProgram: error while creating indicesBuffer\");\n    _this.indicesBuffer = indicesBuffer; // Locations\n\n    _this.positionLocation = gl.getAttribLocation(_this.program, \"a_position\");\n    _this.colorLocation = gl.getAttribLocation(_this.program, \"a_color\");\n    _this.normalLocation = gl.getAttribLocation(_this.program, \"a_normal\");\n    var matrixLocation = gl.getUniformLocation(_this.program, \"u_matrix\");\n    if (matrixLocation === null) throw new Error(\"EdgeProgram: error while getting matrixLocation\");\n    _this.matrixLocation = matrixLocation;\n    var correctionRatioLocation = gl.getUniformLocation(_this.program, \"u_correctionRatio\");\n    if (correctionRatioLocation === null) throw new Error(\"EdgeProgram: error while getting correctionRatioLocation\");\n    _this.correctionRatioLocation = correctionRatioLocation;\n    var sqrtZoomRatioLocation = gl.getUniformLocation(_this.program, \"u_sqrtZoomRatio\");\n    if (sqrtZoomRatioLocation === null) throw new Error(\"EdgeProgram: error while getting sqrtZoomRatioLocation\");\n    _this.sqrtZoomRatioLocation = sqrtZoomRatioLocation; // Enabling the OES_element_index_uint extension\n    // NOTE: on older GPUs, this means that really large graphs won't\n    // have all their edges rendered. But it seems that the\n    // `OES_element_index_uint` is quite everywhere so we'll handle\n    // the potential issue if it really arises.\n    // NOTE: when using webgl2, the extension is enabled by default\n\n    _this.canUse32BitsIndices = (0, utils_1.canUse32BitsIndices)(gl);\n    _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;\n    _this.indicesArray = new _this.IndicesArray();\n    _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;\n\n    _this.bind();\n\n    return _this;\n  }\n\n  EdgeProgram.prototype.bind = function () {\n    var gl = this.gl;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer); // Bindings\n\n    gl.enableVertexAttribArray(this.positionLocation);\n    gl.enableVertexAttribArray(this.normalLocation);\n    gl.enableVertexAttribArray(this.colorLocation);\n    gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n    gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n  };\n\n  EdgeProgram.prototype.computeIndices = function () {\n    var l = this.array.length / ATTRIBUTES;\n    var size = l + l / 2;\n    var indices = new this.IndicesArray(size);\n\n    for (var i = 0, c = 0; i < l; i += 4) {\n      indices[c++] = i;\n      indices[c++] = i + 1;\n      indices[c++] = i + 2;\n      indices[c++] = i + 2;\n      indices[c++] = i + 1;\n      indices[c++] = i + 3;\n    }\n\n    this.indicesArray = indices;\n  };\n\n  EdgeProgram.prototype.bufferData = function () {\n    _super.prototype.bufferData.call(this); // Indices data\n\n\n    var gl = this.gl;\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);\n  };\n\n  EdgeProgram.prototype.process = function (sourceData, targetData, data, hidden, offset) {\n    if (hidden) {\n      for (var i_1 = offset * STRIDE, l = i_1 + STRIDE; i_1 < l; i_1++) this.array[i_1] = 0;\n\n      return;\n    }\n\n    var thickness = data.size || 1,\n        x1 = sourceData.x,\n        y1 = sourceData.y,\n        x2 = targetData.x,\n        y2 = targetData.y,\n        color = (0, utils_1.floatColor)(data.color); // Computing normals\n\n    var dx = x2 - x1,\n        dy = y2 - y1;\n    var len = dx * dx + dy * dy,\n        n1 = 0,\n        n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    var i = POINTS * ATTRIBUTES * offset;\n    var array = this.array; // First point\n\n    array[i++] = x1;\n    array[i++] = y1;\n    array[i++] = n1;\n    array[i++] = n2;\n    array[i++] = color; // First point flipped\n\n    array[i++] = x1;\n    array[i++] = y1;\n    array[i++] = -n1;\n    array[i++] = -n2;\n    array[i++] = color; // Second point\n\n    array[i++] = x2;\n    array[i++] = y2;\n    array[i++] = n1;\n    array[i++] = n2;\n    array[i++] = color; // Second point flipped\n\n    array[i++] = x2;\n    array[i++] = y2;\n    array[i++] = -n1;\n    array[i++] = -n2;\n    array[i] = color;\n  };\n\n  EdgeProgram.prototype.render = function (params) {\n    if (this.hasNothingToRender()) return;\n    var gl = this.gl;\n    var program = this.program;\n    gl.useProgram(program);\n    gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n    gl.uniform1f(this.sqrtZoomRatioLocation, Math.sqrt(params.ratio));\n    gl.uniform1f(this.correctionRatioLocation, params.correctionRatio); // Drawing:\n\n    gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);\n  };\n\n  return EdgeProgram;\n}(edge_1.AbstractEdgeProgram);\n\nexports.default = EdgeProgram;","map":null,"metadata":{},"sourceType":"script"}